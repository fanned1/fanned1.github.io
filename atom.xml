<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>封封の博客</title>
  
  <subtitle>学会倾听,学会止语</subtitle>
  <link href="https://fanned1.github.io/atom.xml" rel="self"/>
  
  <link href="https://fanned1.github.io/"/>
  <updated>2022-11-09T16:57:44.759Z</updated>
  <id>https://fanned1.github.io/</id>
  
  <author>
    <name>封封封</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript基础</title>
    <link href="https://fanned1.github.io/posts/undefined.html"/>
    <id>https://fanned1.github.io/posts/undefined.html</id>
    <published>2022-11-09T16:26:57.585Z</published>
    <updated>2022-11-09T16:57:44.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h1><h2 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h2><ol><li>async：立即异步<strong>下载</strong>，不保证按出现顺序执行（只对外部文件有效）</li><li>defer：立即下载，延迟到文档解析和显示之后<strong>执行</strong>（只对外部文件有效）</li><li>type: module：会被当做es6模块</li></ol><h2 id="var-let-const的区别"><a href="#var-let-const的区别" class="headerlink" title="var\let\const的区别"></a>var\let\const的区别</h2><ol><li>var有声明提升，let和const没有，因此let和const就有了暂时性死区</li><li>var的作用域是函数，let和const的作用域是块</li><li>var和let是变量，const是常量必须在声明时初始化</li><li>var定义的全局变量会成为window的属性，而let和const则不会</li><li>var可以重复声明，let和const则不可以</li></ol><h2 id="判断变量是否是数组"><a href="#判断变量是否是数组" class="headerlink" title="判断变量是否是数组"></a>判断变量是否是数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="comment">// 通过原型中的构造函数判断</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(arr).<span class="property">constructor</span> === <span class="title class_">Array</span></span><br><span class="line"><span class="comment">// 判断是不是数组的构造函数创建的对象</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="6种基本类型"><a href="#6种基本类型" class="headerlink" title="6种基本类型"></a>6种基本类型</h4><ol><li><p>Number</p></li><li><p>Boolean</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">转换为<span class="literal">false</span>的值：</span><br><span class="line"><span class="number">1.</span> <span class="literal">false</span></span><br><span class="line"><span class="number">2.</span> <span class="string">&quot;&quot;</span> <span class="comment">//空字符串</span></span><br><span class="line"><span class="number">3.</span> <span class="number">0</span>、<span class="title class_">NaN</span></span><br><span class="line"><span class="number">4.</span> <span class="literal">null</span></span><br><span class="line"><span class="number">5.</span> <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">逻辑操作符</span><br><span class="line">&amp;&amp; 第一个为<span class="literal">false</span>，返回第一个；否则返回第二个</span><br><span class="line">|| 其中一个为<span class="literal">false</span>，则返回它；否则返回第二个</span><br></pre></td></tr></table></figure></li><li><p>String</p></li><li><p>Null</p></li><li><p>Undefined</p></li><li><p>Symbol 符号是原始值，是唯一、不可变的，用来标识唯一的对象属性，一般是js开发者定义功能使用。</p></li></ol><h4 id="1种引用类型"><a href="#1种引用类型" class="headerlink" title="1种引用类型"></a>1种引用类型</h4><ol><li>Object</li></ol><h2 id="函数定义调用和上下文创建的关系"><a href="#函数定义调用和上下文创建的关系" class="headerlink" title="函数定义调用和上下文创建的关系"></a>函数定义调用和上下文创建的关系</h2><h3 id="执行上下文是什么？（全局上下文、函数上下文、eval-创建的上下文）"><a href="#执行上下文是什么？（全局上下文、函数上下文、eval-创建的上下文）" class="headerlink" title="执行上下文是什么？（全局上下文、函数上下文、eval()创建的上下文）"></a>执行上下文是什么？（全局上下文、函数上下文、eval()创建的上下文）</h3><p>执行上下文就是代码执行的环境，规定了上下文中的变量和函数能访问哪些数据。</p><h3 id="函数在定义和调用的时候发生了什么"><a href="#函数在定义和调用的时候发生了什么" class="headerlink" title="函数在定义和调用的时候发生了什么"></a>函数在定义和调用的时候发生了什么</h3><h4 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h4><p>函数定义的时候，会创建它的作用域链，预装载包含上下文的作用域链，存放在[[scope]]内部属性中</p><h4 id="2-函数调用"><a href="#2-函数调用" class="headerlink" title="2. 函数调用"></a>2. 函数调用</h4><p>函数调用时，会创建该函数的执行上下文；然后通过复制[[scope]]来创建函数的作用域链；接着到了预编译阶段，会创建函数的活动对象作为变量对象，并将它推入作用域链顶端。</p><h3 id="创建执行上下文的时候会发生什么"><a href="#创建执行上下文的时候会发生什么" class="headerlink" title="创建执行上下文的时候会发生什么"></a>创建执行上下文的时候会发生什么</h3><h4 id="1-this绑定"><a href="#1-this绑定" class="headerlink" title="1. this绑定"></a>1. this绑定</h4><ol><li>this绑定又分为直接调用和对象调用；</li><li>直接调用this一般等于window（严格模式除外），对象调用this一般等于该对象。</li></ol><h4 id="2-创建词法环境"><a href="#2-创建词法环境" class="headerlink" title="2. 创建词法环境"></a>2. 创建词法环境</h4><ol><li>词法环境其实就是包含标识符和变量映射关系的一种结构。</li><li>es6中用来存储函数和let、const定义的变量的绑定</li><li>包含环境记录和外部环境引用</li></ol><h4 id="3-创建变量环境"><a href="#3-创建变量环境" class="headerlink" title="3. 创建变量环境"></a>3. 创建变量环境</h4><ol><li>变量环境和词法环境十分相似</li><li>在es6中有明显不同，前者用来存储函数和变量(let/const)的绑定</li><li>后者只用来储存var变量的绑定</li></ol><h3 id="函数预编译"><a href="#函数预编译" class="headerlink" title="函数预编译"></a>函数预编译</h3><ol><li>创建活动对象AO</li><li>找到所有var声明的变量和形参声明，去作为活动对象的属性，置为undefined</li><li>实参和形参值相统一</li><li>找到所有函数声明（不是表达式！）去作为活动对象的属性（会覆盖变量声明），然后将函数体赋值给它</li><li>js解释执行</li></ol><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="标记清理（常用）"><a href="#标记清理（常用）" class="headerlink" title="标记清理（常用）"></a>标记清理（常用）</h3><p>会标记所有在内存中的变量，然后去掉所有<strong>在上下文中的变量</strong>或<strong>被上下文中变量引用的变量</strong>的标记，之后再有标记的变量就一定不在上下文中，并不能被上下文中的变量访问，随后垃圾回收就会清理这些带标记变量并回收内存。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>对每个值都记录它被引用的次数，如果次数为0，则下一次垃圾回收就会回收这个值的内存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">举个栗子</span><br><span class="line">值：<span class="string">&#x27;value&#x27;</span> 次数cnt：<span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;value&#x27;</span> <span class="comment">// cnt ++</span></span><br><span class="line"><span class="keyword">let</span> b = a <span class="comment">// cnt ++</span></span><br><span class="line">a = <span class="string">&#x27;key&#x27;</span><span class="comment">// cnt --</span></span><br><span class="line">b = <span class="string">&#x27;key&#x27;</span><span class="comment">// cnt -- = 0 ‘value’值下次被清理</span></span><br><span class="line"></span><br><span class="line">有个巨大的漏洞-》循环引用</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">problem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> b = &#123;&#125;</span><br><span class="line">    a.<span class="property">next</span> = b</span><br><span class="line">    b.<span class="property">next</span> = a</span><br><span class="line">&#125;</span><br><span class="line">两个&#123;&#125;的引用次数都是<span class="number">2</span></span><br><span class="line">永远不会清<span class="number">0</span>，所有他们会一直在内存中</span><br></pre></td></tr></table></figure><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>本不该在内存中的变量和函数，一直存在于内存中；</p><p>一般就是误定义为全局变量和误使用闭包造成的。</p><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>只要创建一个函数，就会在函数的prototype属性创建一个原型对象，用于给对象 共享方法和属性。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>如果原型是另一个类型的实例，那么原型也有另一个原型，因此便形成了原型链。</p><p>在一个对象中，如果找不到一个属性或方法，就会去原型对象中找，原型对象也有原型，因此便形成了原型链。</p><h2 id="八大继承"><a href="#八大继承" class="headerlink" title="八大继承"></a>八大继承</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;lizhengxin&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">attr</span> = &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">attr</span> === obj1.<span class="property">attr</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">`缺点：</span></span><br><span class="line"><span class="string">1. 在父类构造函数中定义的引用类型属性，是实例间共享的</span></span><br><span class="line"><span class="string">2. 子类实例化时，不能向父类构造函数传参`</span></span><br></pre></td></tr></table></figure><h3 id="2-盗用构造函数"><a href="#2-盗用构造函数" class="headerlink" title="2. 盗用构造函数"></a>2. 盗用构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">attr</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: name ?? <span class="string">&#x27;lizhengxin&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getAttr</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">attr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;son&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;mayana&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)</span><br><span class="line"></span><br><span class="line"><span class="string">`优点：</span></span><br><span class="line"><span class="string">1. 解决了原型链继承的引用值共享问题</span></span><br><span class="line"><span class="string">2. 子类实例化的时候可以给父类构造函数传参了`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`缺点：</span></span><br><span class="line"><span class="string">1. 父类函数只能定义在构造函数内，不能重用</span></span><br><span class="line"><span class="string">2. 不能使用父类原型上的方法和属性`</span></span><br></pre></td></tr></table></figure><h3 id="3-组合继承（原型链-盗用构造函数）"><a href="#3-组合继承（原型链-盗用构造函数）" class="headerlink" title="3. 组合继承（原型链 + 盗用构造函数）"></a>3. 组合继承（原型链 + 盗用构造函数）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">attr</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: name ?? <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAttr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">attr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;lizhengxin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;mayana&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">getAttr</span> === obj2.<span class="property">getAttr</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">`优点：</span></span><br><span class="line"><span class="string">1. 父类私有属性定义在构造函数内，共享方法和属性定义在原型上</span></span><br><span class="line"><span class="string">2. 子类可以访问父类原型上的方法和属性`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`缺点：父类构造函数要被调用两次`</span></span><br></pre></td></tr></table></figure><h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`在一个对象的基础上，建立一个新对象，相当于给传入的对象只醒了一次浅拷贝`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`缺点：跟原型链模式一样，引用值会共享`</span></span><br></pre></td></tr></table></figure><h3 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnthor</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="title function_">object</span>(original)<span class="comment">// 在原对象基础上，建立一个新对象</span></span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">// 并在原基础上，增强新对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`缺点：</span></span><br><span class="line"><span class="string">1. 引用值会共享</span></span><br><span class="line"><span class="string">2. 函数不能重用`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`为什么叫寄生式继承？</span></span><br><span class="line"><span class="string">我觉得是跟是否功能相同有关，就像原型式继承为什么不叫寄生式？那是因为新对象没有增加功能，和源对象一样，这种应该叫共生；而寄生式继承，新对象被增强了，所以就叫做寄生式，就想电影中的寄生兽一样，它在你的基础上建立，但是它最终会变得比你强！`</span></span><br></pre></td></tr></table></figure><h3 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6. 寄生式组合继承"></a>6. 寄生式组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">inheritPrototype</span>(<span class="params">Father, Son</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prototype = <span class="title function_">object</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>)<span class="comment">// 原型式继承父类原型</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = <span class="title class_">Son</span><span class="comment">// 增强</span></span><br><span class="line">    <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">attr</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: name || <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAttr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">attr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Father</span>, <span class="title class_">Son</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;lizhengxin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;mayana&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">`优点：解决了组合继承父类构造函数要调用两次的缺点`</span></span><br></pre></td></tr></table></figure><h3 id="7-类继承类"><a href="#7-类继承类" class="headerlink" title="7. 类继承类"></a>7. 类继承类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="8-类继承构造函数"><a href="#8-类继承构造函数" class="headerlink" title="8. 类继承构造函数"></a>8. 类继承构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="new的过程中发生了什么"><a href="#new的过程中发生了什么" class="headerlink" title="new的过程中发生了什么"></a>new的过程中发生了什么</h2><ol><li>在内存中创建一个新对象</li><li>这个新对象内的原型被赋值为构造函数的prototype原型属性</li><li>构造函数的this被赋值为这个新对象</li><li>逐行执行构造函数内的代码</li><li>如果构造函数返回一个非空对象，则返回这个对象；否则返回刚创建的新对象。</li></ol><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ol><li>箭头函数没有arguments</li><li>箭头函数不能用作构造函数</li><li>箭头函数没有prototype属性</li><li>箭头函数没有this指针，只能使用包含上下文中的this</li><li>箭头函数不能使用new.target，普通函数可以</li></ol><h2 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h2><h3 id="期约的原理就是状态机"><a href="#期约的原理就是状态机" class="headerlink" title="期约的原理就是状态机"></a>期约的原理就是状态机</h3><ol><li>pending，表示未执行或正在执行的过程中</li><li>fulfilled，表示成功的完成</li><li>rejected，表示没有成功的完成</li></ol><p>期约是异步回调地狱的解决方案，在执行器中的报错会自动执行reject(Error)</p><h3 id="promise-all-可迭代对象"><a href="#promise-all-可迭代对象" class="headerlink" title="promise.all(可迭代对象)"></a>promise.all(可迭代对象)</h3><p>在一组promise全部解决后再解决</p><h3 id="promise-race-可迭代对象"><a href="#promise-race-可迭代对象" class="headerlink" title="promise.race(可迭代对象)"></a>promise.race(可迭代对象)</h3><p>在一组promise中只要有一个期约解决或拒绝之后再解决或拒绝，不区分第一个期约是解决或拒绝，只要其中有一个期约落定，rece再之后也会落定</p><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><h3 id="1-事件捕获"><a href="#1-事件捕获" class="headerlink" title="1. 事件捕获"></a>1. 事件捕获</h3><p>事件捕获是指事件从最不具体的元素开始触发，即从层级最浅的元素依次向层级深的元素传递；实际上是为了在到达目标具体元素之前拦截事件。</p><h3 id="2-到达目标"><a href="#2-到达目标" class="headerlink" title="2. 到达目标"></a>2. 到达目标</h3><h3 id="3-事件冒泡"><a href="#3-事件冒泡" class="headerlink" title="3. 事件冒泡"></a>3. 事件冒泡</h3><p>事件冒泡是指事件从最具体的元素开始触发，即从层级最深的元素依次向上传递到层级浅的元素。</p><h2 id="ajax（async-js-and-xml）"><a href="#ajax（async-js-and-xml）" class="headerlink" title="ajax（async js and xml）"></a>ajax（async js and xml）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">const</span> isAsync = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> requstBody = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()<span class="comment">// 创建xhr实例</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/api/getMsg?id=2&#x27;</span>, isAsync)<span class="comment">// 准备要发送的请求，（method，url，isAsync）</span></span><br><span class="line">xhr.<span class="title function_">send</span>(requestBody)<span class="comment">// 正式发送请求，（请求体，一般post会用到）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span> || xhr.<span class="property">status</span> ==<span class="number">304</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span> || xhr.<span class="property">status</span> ==<span class="number">304</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;/api/getMsg?id=2&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;MyHeader&#x27;</span>, <span class="string">&#x27;MyValue&#x27;</span>)<span class="comment">// 设置请求头部字段，必须在open之后send之前设置</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;....&#x27;</span>) <span class="comment">// 发送请求的时候一定记得设置content-type为自己发送的类型</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进度</span></span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">lengthComputable</span>) <span class="comment">// 表示进度信息是否可用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">position</span> / event.<span class="property">totalSize</span> + <span class="string">&#x27;%&#x27;</span>) <span class="comment">// position表示接收到的字节数</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以取消</span></span><br><span class="line">xhr.<span class="title function_">abort</span>()</span><br></pre></td></tr></table></figure><h2 id="简单请求和复杂请求-跨域请求才有"><a href="#简单请求和复杂请求-跨域请求才有" class="headerlink" title="简单请求和复杂请求(跨域请求才有)"></a>简单请求和复杂请求(跨域请求才有)</h2><p>浏览器限制，请求发送出去虽然返回结果被浏览器拦截，但是对服务器可能产生了影响；</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>简单请求只能使用get、post、head这三个方法</p><p>简单请求的 HTTP 头只能是 Accept/Accept-Language/Conent-Language/Content-Type 等</p><p>简单请求的 Content-Type 头只能是 text/plain、multipart/form-data 或 application/x-www-form-urlencoded</p><p>不是复杂请求就是简单请求，就发送一次请求</p><h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3><p>不是简单请求就是复杂请求</p><p>复杂请求在第一次发送这种类型的请求时一共会发送两个请求</p><ol><li>预检请求，使用Options方法（返回204），包含头部：Origin（源域名)、Access-Control-Request-Method(请求想要使用的方法)、Access-Control-Request-Headers(请求定义的自定义头部)    </li><li>正式请求</li></ol><h3 id="凭据请求"><a href="#凭据请求" class="headerlink" title="*凭据请求"></a>*凭据请求</h3><p>如果设置请求属性xhr.withCredentials: true，则这个请求也是凭据请求，请求时会带有(cookie、HTTP认证和客户端ssl证书)，当然也要服务端允许带有才行; Access-Control-Allow-Credentials: true这条语句表示服务端允许带有凭据。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol><li><p>闭包就是引用了其他函数中的变量对象的函数</p></li><li><p>一般发生在嵌套函数，而且内层函数被返回并引用；不返回被引用，则变量对象会被垃圾回收</p></li><li>会导致其他函数的变量对象一直不会销毁</li></ol><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ol><li>只要是直接调用 func(), 那么this就等于window（严格模式等于undefined）</li><li>只要是对象方法调用，那么this就等于该对象</li><li>call\apply\bind调用则this是第一个参数</li></ol><h2 id="发布订阅者模式"><a href="#发布订阅者模式" class="headerlink" title="发布订阅者模式"></a>发布订阅者模式</h2><ol><li>首先确定谁是发布者</li><li>然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者</li><li>最后就是发布消息，遍历缓存列表，依次触发里面存放的订阅者回调函数</li></ol><h1 id="手写js代码"><a href="#手写js代码" class="headerlink" title="手写js代码"></a>手写js代码</h1><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCall</span>(<span class="params">thisPtr, ...params</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> thisPtr !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    thisPtr = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  thisPtr.<span class="property">temp</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisPtr.<span class="title function_">temp</span>(...arrParams)</span><br><span class="line">  <span class="keyword">delete</span> thisPtr.<span class="property">temp</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = myCall</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myApply</span>(<span class="params">thisPtr, arrParams</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> thisPtr !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    thisPtr = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  thisPtr.<span class="property">temp</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> res = thisPtr.<span class="title function_">temp</span>(...arrParams)</span><br><span class="line">  <span class="keyword">delete</span> thisPtr.<span class="property">temp</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = myApply</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myBind</span>(<span class="params">thisPtr, arrArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> thisPtr !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    thisPtr = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arrArg = arrArg || []</span><br><span class="line">  <span class="keyword">const</span> originalFunc = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果new 构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> bound) &#123;</span><br><span class="line">      <span class="comment">// 构造函数的 this指针 要指向所创建的对象，就是现在this</span></span><br><span class="line">      thisPtr = <span class="variable language_">this</span></span><br><span class="line">      <span class="comment">// 实例的原型应该被赋值为原来函数的原型</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">__proto__</span> = originalFunc.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> originalFunc.<span class="title function_">myApply</span>(thisPtr, arrArg.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = myBind</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;blabla  : &#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>, <span class="string">&#x27;age : &#x27;</span>, age)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;lizhengxin&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.bind(obj)(20)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bound = test.<span class="title function_">myBind</span>(obj)</span><br><span class="line"><span class="title function_">bound</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title function_">bound</span>(<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">gender</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">gender</span>)</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">func, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    newObj.<span class="property">__proto__</span> = func.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    <span class="keyword">const</span> res = func.<span class="title function_">call</span>(func, ...args)</span><br><span class="line">    <span class="comment">// 如果构造函数返回非空对象，则返回该对象</span></span><br><span class="line">    <span class="keyword">if</span> (res !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="title class_">Object</span>.<span class="title function_">keys</span>(res).<span class="property">length</span> !== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment">// 否则返回新对象</span></span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromiseAll</span>(<span class="params">arrArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arrArgs)) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是数组&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> len = arrArgs.<span class="property">length</span></span><br><span class="line">        <span class="keyword">const</span> arrAns = []</span><br><span class="line">        arrArgs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, idx</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// resolve包装一下</span></span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                arrAns[idx] = res</span><br><span class="line">                cnt ++ </span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= len) <span class="title function_">resolve</span>(arrAns)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromiseRace</span>(<span class="params">arrArg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arrArg)) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是数组&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        </span><br><span class="line">        arrArgs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, idx</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(res)</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/api/login&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;lizhengxin&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;lizhengxin&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span> || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">root</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(root)) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是数组&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> arrAns = []</span><br><span class="line">    root.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) </span><br><span class="line">        &#123;</span><br><span class="line">            arrAns = arrAns.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(item))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arrAns.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arrAns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash方式，O(n)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeRepetition</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是数组&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> visit = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> ans = []</span><br><span class="line">    </span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, idx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[item] === <span class="literal">undefined</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(item)</span><br><span class="line">            visit[item] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort方式，O(nlogn)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeRepetition</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">arr.<span class="title function_">sort</span>()</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || arr[i] !== arr[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j ++ ] = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="property">length</span> = j</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听数组改变"><a href="#监听数组改变" class="headerlink" title="监听数组改变"></a>监听数组改变</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reflect = &#123;&#125;</span><br><span class="line">reflect.<span class="property">push</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span></span><br><span class="line">reflect.<span class="property">pop</span> = A</span><br></pre></td></tr></table></figure><h2 id="防抖节流函数"><a href="#防抖节流函数" class="headerlink" title="防抖节流函数"></a>防抖节流函数</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="title function_">callback</span>(...args) </span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">callback</span>(...args)</span><br><span class="line">                timer = <span class="literal">undefined</span></span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="css基础"><a href="#css基础" class="headerlink" title="css基础"></a>css基础</h1><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>盒子模型就是容纳html元素的一个容器，有宽高、边距、边框等</p><h3 id="普通盒子-box-sizing-content-box"><a href="#普通盒子-box-sizing-content-box" class="headerlink" title="普通盒子(box-sizing: content-box)"></a>普通盒子(box-sizing: content-box)</h3><p>宽高就是自身的宽高，然后边框和内边距不计算在内</p><h3 id="怪异盒子-box-sizing-border-box"><a href="#怪异盒子-box-sizing-border-box" class="headerlink" title="怪异盒子(box-sizing: border-box)"></a>怪异盒子(box-sizing: border-box)</h3><p>宽高 = 自身宽高 + padding + border</p><h2 id="BFC块级格式化上下文"><a href="#BFC块级格式化上下文" class="headerlink" title="BFC块级格式化上下文"></a>BFC块级格式化上下文</h2><ol><li><p>定义：BFC是一个完全独立渲染的空间，让其子元素不受外部元素的任何影响。</p></li><li><p>作用：用于解决高度塌陷、margin重叠、浮动问题</p></li><li><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> float 不为none 脱离文档流</span><br><span class="line"><span class="number">2.</span> position 是absolute和fixed 脱离文档流</span><br><span class="line"><span class="number">2.</span> display 为inline-block, flex, inline-flex, table, table-cell, inline-table</span><br><span class="line"><span class="number">3.</span> overflow 不为visible</span><br></pre></td></tr></table></figure></li></ol><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="relative-transform-子元素不固定宽高"><a href="#relative-transform-子元素不固定宽高" class="headerlink" title="relative + transform 子元素不固定宽高"></a>relative + transform 子元素不固定宽高</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-子元素不固定宽高"><a href="#flex-子元素不固定宽高" class="headerlink" title="flex 子元素不固定宽高"></a>flex 子元素不固定宽高</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span>&#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    justify-<span class="attr">content</span>: center;</span><br><span class="line">    aligh-<span class="attr">items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex变异布局"><a href="#flex变异布局" class="headerlink" title="flex变异布局"></a>flex变异布局</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">son</span> &#123;</span><br><span class="line">    <span class="attr">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="grid-子元素不固定宽高"><a href="#grid-子元素不固定宽高" class="headerlink" title="grid 子元素不固定宽高"></a>grid 子元素不固定宽高</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">    <span class="attr">display</span>: grid;</span><br><span class="line">    justify-<span class="attr">self</span>: center;</span><br><span class="line">    aligh-<span class="attr">self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="grid变异布局"><a href="#grid变异布局" class="headerlink" title="grid变异布局"></a>grid变异布局</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">    <span class="attr">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">son</span> &#123;</span><br><span class="line">    <span class="attr">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="absolute-margin-子元素固定宽高"><a href="#absolute-margin-子元素固定宽高" class="headerlink" title="absolute + margin 子元素固定宽高"></a>absolute + margin 子元素固定宽高</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">father</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">son</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    <span class="attr">height</span>: 200px;</span><br><span class="line">    <span class="attr">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><h3 id="float-margin"><a href="#float-margin" class="headerlink" title="float  + margin"></a>float  + margin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">   <span class="attr">float</span>: left;</span><br><span class="line">    <span class="attr">width</span>: 200px</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">    margin-<span class="attr">left</span>: 210px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="float-BFC"><a href="#float-BFC" class="headerlink" title="float + BFC"></a>float + BFC</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">    <span class="attr">float</span>: left;</span><br><span class="line">    <span class="attr">width</span>: 200px</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">    <span class="attr">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">wrapper</span> &#123;</span><br><span class="line">    <span class="attr">display</span>: flex</span><br><span class="line">    align-<span class="attr">items</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    flex-<span class="attr">shrink</span>: <span class="number">0</span>; <span class="comment">// flex的第二个参数禁止收缩</span></span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">    <span class="attr">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="absolute-margin"><a href="#absolute-margin" class="headerlink" title="absolute+ margin"></a>absolute+ margin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">width</span>: 200px</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">    margin-<span class="attr">left</span>: 200px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="absolute-absolute-left"><a href="#absolute-absolute-left" class="headerlink" title="absolute + absolute . left"></a>absolute + absolute . left</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">left</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">width</span>: 200px</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">right</span> &#123;</span><br><span class="line">   <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">left</span>: 200px;</span><br><span class="line">    <span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><h3 id="流体布局-浮动布局-跟-position差不多"><a href="#流体布局-浮动布局-跟-position差不多" class="headerlink" title="流体布局(浮动布局) 跟 position差不多"></a>流体布局(浮动布局) 跟 position差不多</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>; // marin法</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: auto: // BFC法</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="圣杯"><a href="#圣杯" class="headerlink" title="圣杯"></a>圣杯</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">原理：外部盒子给出两栏宽度的padding，三个元素都浮动，通过margin 和 relative 调整两栏变到一行去</span><br><span class="line">缺点：屏幕宽度小于两栏宽度 + padding时，布局会乱</span><br><span class="line">`类书写的顺序，就是元素排版的顺序`</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span></span></span><br><span class="line"><span class="language-css">            margin-left: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="双飞翼（完满三栏）"><a href="#双飞翼（完满三栏）" class="headerlink" title="双飞翼（完满三栏）"></a>双飞翼（完满三栏）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">原理：在圣杯的基础上，删去了外部容器的padding，让外部容器宽度100%的浏览器宽度，margin-left参照的宽度变大，因此不需要relative，也就解决了宽度小于两栏宽度+padding时布局会乱的问题（因为relative元素一直在原地）；重点通过在main中加了main-content，使用其margin空出两栏位置</span><br><span class="line"></span><br><span class="line">`类书写的顺序，就是元素排版的顺序`</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            </span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.main-content</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><ol><li>!important 是最高优先级</li><li>css将 <strong>行内样式、id选择器、类/伪类/属性选择器、元素/伪元素选择器，按次序划分为一个四位元组(0, 0, 0, 0)</strong>；比如：每多一个类选择器第三位就 + 1，比较方式就是从前向后一次比较，类似字符串比较</li><li>其余就不计算在优先级内</li></ol><h2 id="文字超出省略号"><a href="#文字超出省略号" class="headerlink" title="文字超出省略号"></a>文字超出省略号</h2><h3 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">one</span>-line &#123;</span><br><span class="line"><span class="attr">overflow</span>: hidden;</span><br><span class="line">    text-<span class="attr">overflow</span>: ellipsis;</span><br><span class="line">    white-<span class="attr">space</span>: no-wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">many</span>-lines &#123;</span><br><span class="line">    <span class="attr">overflow</span>: hidden;</span><br><span class="line">    <span class="attr">display</span>: -webkit-box;</span><br><span class="line">    -webkit-box-<span class="attr">orient</span>: vertical;</span><br><span class="line">    -webkit-line-<span class="attr">clamp</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="z-index在什么时候有效"><a href="#z-index在什么时候有效" class="headerlink" title="z-index在什么时候有效"></a>z-index在什么时候有效</h2><p>当position被设置为 absolute, fixed, relative, sticky时，元素的层级会变得比普通元素高，同时就可以使用z-index进行层级调整</p><p>注意：</p><ol><li>设置z-index层级只对兄弟节点有效</li><li>当position：sticky时，将z-index设置为&lt;=0时，会使sticky本身功能丧失</li></ol><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>beforeCreate 实例初始化之后，设置数据监听、事件监听、属性、方法之前调用</li><li>created 实例创建完成后调用，即数据监听、事件监听、属性、方法被配置完毕后调用</li><li>beforeMount 挂载开始之前调用</li><li>mounted 实例挂载完后调用，但不保证所有子组件都挂载完成</li><li>beforeUpdate 数据修改后，dom渲染前调用</li><li>updated 修改后的数据已经渲染到dom之后调用，但不保证的所有子组件都渲染完成</li><li>activated 被keep-alive缓存的组件激活时调用</li><li>deactivated 被keep-alive缓存的组件失活时调用</li><li>beforeDestroy 实例销毁前调用，此时实例完全可用</li><li>destroyed 实例销毁后调用</li></ol><h2 id="父子组件生命周期的执行顺序"><a href="#父子组件生命周期的执行顺序" class="headerlink" title="父子组件生命周期的执行顺序"></a>父子组件生命周期的执行顺序</h2><p>父beforeCreate-&gt; 父created -&gt; 父beforeMounte -&gt; 子beforeCreate -&gt;子created -&gt;子beforeMount -&gt;子 mounted -&gt; 父mounted</p><p>父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件是可复用的vue实例</p><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>插槽是内容分发的出口，一般用于封装组件，封装的组件只实现一个通用的框架，具体的内容需要开发者自己提供</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>设置了名字的插槽，叫做具名插槽，默认名字为：default</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;son&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;  &lt;slot name=&quot;nameSlot&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在子组件中通过$slot.插槽名，可以获取父组件插槽中的内容</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$slot</span>.<span class="property">default</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他组件中使用</span></span><br><span class="line"><span class="comment">// v-slot 可以缩写为 # </span></span><br><span class="line">&lt;son&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:nameSlot</span>&gt;</span> 你的内容 <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span> &lt;/son&gt;</span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽就是让插槽内容能够访问子组件中的数据，通过给<slot>元素设置属性（插槽prop）实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;son&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;  &lt;slot name=&quot;nameSlot&quot; :user=&quot;user&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他组件中使用，通过带值得 v-slot 引用 插槽prop</span></span><br><span class="line">&lt;son&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:nameSlot</span>=<span class="string">&quot;user&quot;</span>&gt;</span> 你的内容 &#123;&#123; user.nickname &#125;&#125; <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span> &lt;/son&gt;</span><br></pre></td></tr></table></figure><h2 id="动态组件和异步组件"><a href="#动态组件和异步组件" class="headerlink" title="动态组件和异步组件"></a>动态组件和异步组件</h2><ol><li><p>动态组件是指动态生成组件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过is属性实现</span></span><br><span class="line">&lt;component :is=<span class="string">&quot;componentName&quot;</span>&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure></li><li><p>异步组件是指 按需异步加载组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue允许你用一个工厂函数定义你的组件，这函数被调用的时，会异步解析你的组件定义，并缓存结果复用。</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component1&#x27;</span>, <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/components/component1&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ol><h2 id="组件data为什么一定要定义成函数"><a href="#组件data为什么一定要定义成函数" class="headerlink" title="组件data为什么一定要定义成函数"></a>组件data为什么一定要定义成函数</h2><p>因为组件是可以用来创建多个实例，如果data还是一个对象的话，那么所有实例将引用同一个数据对象；使用函数就不会这样，函数在创建一个组件实例的时候会被调用，然后返回一个数据对象的副本；</p><h2 id="props自定义属性"><a href="#props自定义属性" class="headerlink" title="props自定义属性"></a>props自定义属性</h2><ol><li>props对于基本数据类型是单向数据流的，父组件发生改变会传递到子组件，子组件一般不循序改变props</li><li>props对于引用类型，子组件可以改变引用类型的属性，因为是按引用值传递，所以父组件会跟着改变</li><li>props可以执行验证等操作</li></ol><h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ol><li>计算属性的结果会被缓存（<strong>并不是访问一次就计算一次</strong>），除非依赖的<strong>响应式</strong>属性改变了才会重新计算（如果某个属性不是响应式则不会重新计算）</li><li>用于解决在模板中的进行复杂逻辑计算难以维护的问题 </li><li>用于一个属性需要随着其他属性变动而变动的情况</li><li>默认情况下是getter的回调，可以通过设置setter来达到重新赋值给计算属性时，在回调中按特定规则更新依赖</li><li>因为getter是通过同步执行一次来计算结果的，所以执行异步操作对结果没有任何影响</li></ol><h2 id="watch监听属性"><a href="#watch监听属性" class="headerlink" title="watch监听属性"></a>watch监听属性</h2><ol><li>watch用于监听数据的变化</li><li>用于数据变化时执行异步操作或开销比较大的操作</li></ol><h2 id="vue2-和-vue3-的区别"><a href="#vue2-和-vue3-的区别" class="headerlink" title="vue2 和 vue3 的区别"></a>vue2 和 vue3 的区别</h2><h3 id="数据响应式"><a href="#数据响应式" class="headerlink" title="数据响应式"></a>数据响应式</h3><ol><li><p>vue2 使用 Object.defineProperty()不能响应式监听对象新增属性和删除属性，以及不能直接通过下标修改数组元素。vue3 使用 Proxy 监听对象可以实现。</p></li><li><p>vue3新增composition（组合式） API，将data，methods、生命周期钩子函数都写在一堆，然后封装成一个hook，将同一功能的代码组合在一起。不用再像vue2那样，要去data里定义数据、methods里定义方法、生命周期钩子里边写代码，代码关联系不高。</p></li><li><p>vue3 优化了更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 事件缓存，定义了事件，就会缓存，下一次执行渲染函数，就不会重新构建</span><br><span class="line"><span class="number">2.</span> 静态标记，在生成渲染函数的过程中，打上patchFlags，然后在patch的过程中判断标记来优化diff</span><br><span class="line"><span class="number">3.</span> 静态提升，将不会变的节点或属性，将他们序列化为字符串，以此减少渲染成本，例：<span class="title function_">_createStaticVnode</span>(<span class="string">&quot;&lt;div&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;foo\&quot;&gt;&lt;/span&gt;&lt;/div&gt;&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h2><p>给对象添加监听属性，遍历对象、数组实现递归监听。</p><h2 id="Dep类"><a href="#Dep类" class="headerlink" title="Dep类"></a>Dep类</h2><p>Dep类是用来给数组和对象存储watcher依赖的类。</p><h3 id="Watcher类"><a href="#Watcher类" class="headerlink" title="Watcher类"></a>Watcher类</h3><p>watcher类就是观察者，用来当数据改变后，执行响应操作。</p><h2 id="收集依赖defineReactive"><a href="#收集依赖defineReactive" class="headerlink" title="收集依赖defineReactive"></a>收集依赖defineReactive</h2><p>主要通过getter收集依赖，通过setter通知更新；收集依赖的根据就是当前Dep的watcher栈是否有watcher，如果有，那么就把当前watcher当做依赖收集起来。</p><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>就是通过Object.defineProperty(obj, key, {set: …., get:…})递归监听对象的所有属性。</p><h2 id="生成ast树"><a href="#生成ast树" class="headerlink" title="生成ast树"></a>生成ast树</h2><p>模板渲染生成ast树（抽象语法树）</p><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>diff算法就是对 新 旧 vnode 进行层序比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">采取四种状态</span><br><span class="line">新前 旧前<span class="comment">// 移动指针</span></span><br><span class="line">新后 旧后<span class="comment">// 移动指针</span></span><br><span class="line">新后 旧前<span class="comment">// 涉及到移动节点，旧前的dom节点移动到旧后之后，然后旧前vnode置为undefined</span></span><br><span class="line">新前 旧后<span class="comment">// 涉及到移动节点，旧后的dom节点移动到旧前之前， 然后旧后vnode置为undefined</span></span><br><span class="line"></span><br><span class="line">如果以上四种状态都没有匹配上，那么就进行暴力匹配，用旧子节点的key生成个map，然后查看新前的key是否存在。</span><br><span class="line">将新前拿去匹配旧vnode中的节点，如果匹配到，将旧vnode的dom节点移动到旧前之前，并将vnode置为<span class="literal">undefined</span>；否则，直接将新前插入到旧前之前</span><br><span class="line"></span><br><span class="line">特殊情况：</span><br><span class="line">旧子节点遍历完了，新子节点还没遍历完，则将新前~新后之间的节点，插入到旧子节点新前序号之前</span><br><span class="line">旧子节点没遍历完，新子节点遍历完了，则将旧前~旧后之间的节点删除。</span><br></pre></td></tr></table></figure><h2 id="nextTick机制"><a href="#nextTick机制" class="headerlink" title="nextTick机制"></a>nextTick机制</h2><p>通过在一个宏任务或微任务中update Watcher，因此无论主执行栈中的同步代码针对同一个Wather update多少次，在异步任务中只会update一次。</p><p>一个异步任务执行callbacks[]数组中的多个回调函数，$nextTick就是通过push进callbacks数组实现的。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211117175010290.png" alt="image-20211117175010290"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> waiting 表示 flushSchedulerQueue（run当前queue中所有watcher实例），是否加入callbacks事件队列；如果为真，就不会再把该函数加入队列，否则加入。</span><br><span class="line"><span class="keyword">let</span> flushing 表示 flushSchedulerQueue 是否正在run当前queue中的所有watcher实例；如果为假表示还没有清空queue直接加入。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = [] 是保存需要执行更新操作的watcher</span><br><span class="line"><span class="keyword">const</span> callbacks = [] 用来模拟事件队列，是保存下一次tick需要执行的回调函数</span><br><span class="line"><span class="keyword">const</span> timerFunc = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="built_in">setTimeout</span>(nextTickHandler, <span class="number">0</span>)&#125; 异步函数，用来添加异步任务，promise.<span class="title function_">then</span>() &gt; <span class="built_in">setTimeout</span>()，执行事件队列中的所有事件.</span><br><span class="line"><span class="keyword">let</span> pending 表示当前是否正在执行timerFunc，如果正在执行，则加入事件队列中等待。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决当前主执行栈中的代码多次更新数据造成的多次更新vnode，所以使用异步更新，同一个更新任务只会加入队列一次。</span><br></pre></td></tr></table></figure><h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h2><p>Keep-Alive跟普通组件一样，也会进行实例化和挂载，因此会触发它的render函数，render函数实现了缓存vnode的功能；如果keep-alive里的组件改变，那么会触发updateChildComponent会执行vm.$forceUpdate所以keep-alive组件也会被重新渲染，keep-alive就会再一次执行render并处理传入的vnode。</p><h1 id="sql语句复习"><a href="#sql语句复习" class="headerlink" title="sql语句复习"></a>sql语句复习</h1><h2 id="distinct-去重"><a href="#distinct-去重" class="headerlink" title="distinct 去重"></a>distinct 去重</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> user_id <span class="keyword">from</span> tb_blog</span><br></pre></td></tr></table></figure><h2 id="insert-into-表名-列名-values-列值"><a href="#insert-into-表名-列名-values-列值" class="headerlink" title="insert into 表名 (列名) values (列值)"></a>insert into 表名 (列名) values (列值)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_admin (admin_id, account, password, create_time) <span class="keyword">values</span> (<span class="keyword">null</span>, <span class="string">&#x27;myn&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, now())</span><br></pre></td></tr></table></figure><h2 id="update-表名-set-字段名-字段值"><a href="#update-表名-set-字段名-字段值" class="headerlink" title="update 表名 set 字段名=字段值"></a>update 表名 set 字段名=字段值</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_admin <span class="keyword">set</span> password <span class="operator">=</span> <span class="string">&#x27;sbmayana&#x27;</span> <span class="keyword">where</span> admin_id <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="delete-from-表名-where-键-值"><a href="#delete-from-表名-where-键-值" class="headerlink" title="delete from 表名 where 键=值"></a>delete from 表名 where 键=值</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_admin <span class="keyword">where</span> admin_id <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="limit-0-5-等价于-limit-5-offset-0"><a href="#limit-0-5-等价于-limit-5-offset-0" class="headerlink" title="limit 0, 5 等价于 limit 5 offset 0"></a>limit 0, 5 等价于 limit 5 offset 0</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_blog limit <span class="number">5</span> <span class="keyword">offset</span> <span class="number">0</span> <span class="operator">/</span><span class="operator">/</span> 表示从第<span class="number">0</span>条记录开始，取<span class="number">5</span>条记录</span><br></pre></td></tr></table></figure><h2 id="like通配符，-表示0个或多个字符，-代表一个字符"><a href="#like通配符，-表示0个或多个字符，-代表一个字符" class="headerlink" title="like通配符，%表示0个或多个字符，_代表一个字符"></a>like通配符，%表示0个或多个字符，_代表一个字符</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> nickname <span class="keyword">from</span> tb_user <span class="keyword">where</span> nickname <span class="keyword">like</span> <span class="string">&#x27;[lunalizhengxin]%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="in-元组"><a href="#in-元组" class="headerlink" title="in 元组"></a>in 元组</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> nickname <span class="keyword">from</span> tb_user <span class="keyword">where</span> nickname <span class="keyword">in</span> (<span class="string">&#x27;lizhengxin&#x27;</span>, <span class="string">&#x27;luna&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="union-select语句"><a href="#union-select语句" class="headerlink" title="union + select语句"></a>union + select语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_admin <span class="keyword">union</span> <span class="keyword">select</span> user_id, nickname, password, account, <span class="number">5</span>, <span class="number">6</span> <span class="keyword">from</span> tb_user</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 将两个多个<span class="keyword">select</span>语句查询到的数据合并到第一个<span class="keyword">select</span>的列下，要求后面的<span class="keyword">select</span>语句的列数要与第一个<span class="keyword">select</span>一致</span><br></pre></td></tr></table></figure><h2 id="给表中字段新建索引create-index-索引名-on-表名-列1，列2-…"><a href="#给表中字段新建索引create-index-索引名-on-表名-列1，列2-…" class="headerlink" title="给表中字段新建索引create index 索引名 on 表名 (列1，列2,…)"></a>给表中字段新建索引create index 索引名 on 表名 (列1，列2,…)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （加快查询速度，但是会减慢更新速度，因为索引也需要更新）</span></span><br><span class="line"><span class="variable constant_">CREATE</span> <span class="variable constant_">INDEX</span> <span class="title class_">PersonIndex</span> <span class="variable constant_">ON</span> <span class="title class_">Person</span> (<span class="title class_">LastName</span>, <span class="title class_">FirstName</span>)</span><br></pre></td></tr></table></figure><h2 id="Date日期类函数"><a href="#Date日期类函数" class="headerlink" title="Date日期类函数"></a>Date日期类函数</h2><h3 id="now-，curdate-curtime"><a href="#now-，curdate-curtime" class="headerlink" title="now()，curdate(), curtime()"></a>now()，curdate(), curtime()</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> now(), curdate(), curtime()</span><br><span class="line"></span><br><span class="line">now() 表示当前的日期的datetime类型</span><br><span class="line">curdate() 当前日期的<span class="type">date</span>类型</span><br><span class="line">curtime() 当前日期的<span class="type">time</span>类型</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211104101603459.png" alt="image-20211104101603459"></p><h3 id="date-日期或时间-提取日期或时间中的日期-date-部分"><a href="#date-日期或时间-提取日期或时间中的日期-date-部分" class="headerlink" title="date(日期或时间) 提取日期或时间中的日期(date)部分"></a>date(日期或时间) 提取日期或时间中的日期(date)部分</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="type">date</span>(create_time) <span class="keyword">from</span> tb_blog</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211104102053136.png" alt="image-20211104102053136"></p><h3 id="extract-部分名-from-日期时间字段名-提取日期时间中的部分"><a href="#extract-部分名-from-日期时间字段名-提取日期时间中的部分" class="headerlink" title="extract(部分名 from 日期时间字段名) 提取日期时间中的部分"></a>extract(部分名 from 日期时间字段名) 提取日期时间中的部分</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">extract</span>(DAY_MICROSECOND</span><br><span class="line"> <span class="keyword">from</span> create_time), <span class="built_in">extract</span>(DAY_MICROSECOND</span><br><span class="line"> <span class="keyword">from</span> test_date), <span class="built_in">extract</span>(DAY_MICROSECOND</span><br><span class="line"> <span class="keyword">from</span> test_time) <span class="keyword">from</span> tb_blog</span><br><span class="line"></span><br><span class="line">`部分名：`</span><br><span class="line">MICROSECOND</span><br><span class="line"><span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">MINUTE</span></span><br><span class="line"><span class="keyword">HOUR</span></span><br><span class="line"><span class="keyword">DAY</span></span><br><span class="line">WEEK</span><br><span class="line"><span class="keyword">MONTH</span></span><br><span class="line">QUARTER</span><br><span class="line"><span class="keyword">YEAR</span></span><br><span class="line">SECOND_MICROSECOND</span><br><span class="line">MINUTE_MICROSECOND</span><br><span class="line">MINUTE_SECOND</span><br><span class="line">HOUR_MICROSECOND</span><br><span class="line">HOUR_SECOND</span><br><span class="line">HOUR_MINUTE</span><br><span class="line">DAY_MICROSECOND</span><br><span class="line">DAY_SECOND</span><br><span class="line">DAY_MINUTE</span><br><span class="line">DAY_HOUR</span><br><span class="line">YEAR_MONTH</span><br></pre></td></tr></table></figure><h3 id="DATE-ADD-date-interval-value-type-函数向日期添加指定的时间间隔"><a href="#DATE-ADD-date-interval-value-type-函数向日期添加指定的时间间隔" class="headerlink" title="DATE_ADD(date, interval value type) 函数向日期添加指定的时间间隔"></a>DATE_ADD(date, interval value type) 函数向日期添加指定的时间间隔</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(create_time, <span class="type">interval</span> <span class="number">30</span> <span class="keyword">day</span>) <span class="keyword">from</span> tb_blog <span class="operator">/</span><span class="operator">/</span> 加三十天</span><br><span class="line">`type值：`</span><br><span class="line">MICROSECOND</span><br><span class="line"><span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">MINUTE</span></span><br><span class="line"><span class="keyword">HOUR</span></span><br><span class="line"><span class="keyword">DAY</span></span><br><span class="line">WEEK</span><br><span class="line"><span class="keyword">MONTH</span></span><br><span class="line">QUARTER</span><br><span class="line"><span class="keyword">YEAR</span></span><br><span class="line">SECOND_MICROSECOND</span><br><span class="line">MINUTE_MICROSECOND</span><br><span class="line">MINUTE_SECOND</span><br><span class="line">HOUR_MICROSECOND</span><br><span class="line">HOUR_SECOND</span><br><span class="line">HOUR_MINUTE</span><br><span class="line">DAY_MICROSECOND</span><br><span class="line">DAY_SECOND</span><br><span class="line">DAY_MINUTE</span><br><span class="line">DAY_HOUR</span><br><span class="line">YEAR_MONTH</span><br></pre></td></tr></table></figure><h3 id="DATE-SUB-date-interval-value-type-函数向日期减去指定的时间间隔"><a href="#DATE-SUB-date-interval-value-type-函数向日期减去指定的时间间隔" class="headerlink" title="DATE_SUB(date, interval value type) 函数向日期减去指定的时间间隔"></a>DATE_SUB(date, interval value type) 函数向日期减去指定的时间间隔</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> test_time, date_sub(now(), <span class="type">interval</span> <span class="number">30</span> <span class="keyword">day</span>), datediff(date_sub(now(), <span class="type">interval</span> <span class="number">30</span> <span class="keyword">day</span>), test_time) <span class="keyword">from</span> tb_blog</span><br></pre></td></tr></table></figure><h3 id="DATEDIFF-date1-date2-函数返回第一个日期减去第二个日期的天数"><a href="#DATEDIFF-date1-date2-函数返回第一个日期减去第二个日期的天数" class="headerlink" title="DATEDIFF(date1, date2) 函数返回第一个日期减去第二个日期的天数"></a>DATEDIFF(date1, date2) 函数返回第一个日期减去第二个日期的天数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> test_time, date_sub(now(), <span class="type">interval</span> <span class="number">30</span> <span class="keyword">day</span>), datediff(date_sub(now(), <span class="type">interval</span> <span class="number">30</span> <span class="keyword">day</span>), test_time) <span class="keyword">from</span> tb_blog</span><br></pre></td></tr></table></figure><h3 id="date-format-date-format-格式化日期"><a href="#date-format-date-format-格式化日期" class="headerlink" title="date_format(date, format) 格式化日期"></a>date_format(date, format) 格式化日期</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> create_time, date_format(create_time, <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>) <span class="keyword">from</span> tb_blog</span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><h3 id="对称加密（AES"><a href="#对称加密（AES" class="headerlink" title="对称加密（AES)"></a>对称加密（AES)</h3><ol><li>对称加密是指 加密 和 解密的两方使用相同的秘钥</li><li>优点：加密、解密速度快</li><li>缺点：在第一次交换秘钥的过程中，容易暴露给别人</li></ol><h3 id="非对称加密-RSA"><a href="#非对称加密-RSA" class="headerlink" title="非对称加密(RSA)"></a>非对称加密(RSA)</h3><ol><li>非对称加密是指 加密 和 解密的两方使用不同的秘钥进行加密和解密（用公钥加密后的数据，只有私钥能解密）</li><li>优点：使用两个秘钥，安全性较高，解决了第一次交换秘钥的过程中，容易暴露的问题</li><li>缺点：加密、解密的过程会比对称加密慢很多</li></ol><h2 id="HTTPS的握手过程"><a href="#HTTPS的握手过程" class="headerlink" title="HTTPS的握手过程"></a><a href="https://segmentfault.com/a/1190000021494676#comment-area">HTTPS的握手过程</a></h2><p>安全原理，结合了对称加密和非对称加密的优点，使用非对称加密 传输 对称加密的秘钥，弥补了在传输过程中可能被截取对称加密秘钥的问题 和 完全使用非对称加密速度远比对称加密慢很多的问题</p><p><img src="https://segmentfault.com/img/bVbCCMD" alt="SSL : TLS 握手过程" style="zoom: 150%;" /></p><ol><li><strong>client hello</strong>消息：客户端向服务端发送<strong>client hello</strong>消息发起握手请求，该消息包含了客户端所支持的 <strong>TLS版本</strong>、<strong>加密算法的组合</strong>以及一个随机字符串”<strong>client random</strong>“</li><li>“server hello”消息：服务端收到握手请求向服务端返回“server hello”消息，该消息包含了<strong><code>CA</code>证书、选择的加密算法组合</strong>以及一个随机字符串”<strong>server random</strong>“</li><li><strong>premaster secret</strong>字符串：客户端收到服务端<strong>server hello</strong>消息后，进行证书验证，并从证书中获取<strong>公钥</strong>，然后生成下一个随机字符串<strong>premaster secret</strong>将其用公钥加密后，发送给服务器</li><li>服务端收到客户端发来的<strong>premaster secret</strong>字符串，用私钥将其解密</li><li>客户端和服务器使用相同的加密算法对 <strong>client random、server random、premaster secret</strong>进行加密生成对称加密秘钥key</li><li>客户端发送经过key加密过的<strong>finished</strong>信号</li><li>服务端发送经过key加密过的<strong>finished</strong>信号</li><li>握手完成</li></ol><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ol><li>最重要的区别就是安全，HTTP明文传输，没有对数据进行加密安全性较差；HTTPS（HTTP + TLS/SSL）数据传输过程加密安全性较好</li><li>使用HTTPS需要去专门的机构申请CA证书，需要花费一定费用</li><li>HTTP页面响应速度比HTTPS快，由于加了一层安全层，建立连接的过程更复杂，需要交换更多数据；而且加密解密的过程也需要时间，难免会变慢</li><li>HTTP和HTTPS使用的端口也不一样，前者用443，后者用80</li></ol><h2 id="HTTP1-0-和-HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-0-和-HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.0 和 HTTP1.1和HTTP2.0的区别"></a>HTTP1.0 和 HTTP1.1和HTTP2.0的区别</h2><h3 id="HTTP1-0-和-HTTP1-1的区别"><a href="#HTTP1-0-和-HTTP1-1的区别" class="headerlink" title="HTTP1.0 和 HTTP1.1的区别"></a>HTTP1.0 和 HTTP1.1的区别</h3><ol><li><p><strong>缓存处理</strong></p><p><strong>HTTP1.0</strong>主要使用If-Modified-Since和Expires来做为缓存判断的标准，<strong>HTTP1.1</strong>则新增了更多缓存控制策略Entity tag、If-None-Match、cache-control等等。</p></li><li><p><strong>长连接</strong></p><p><strong>HTTP1.0</strong>默认短连接，即没发送一次HTTP请求就要新建一个TCP连接，浪费了很多资源在新建连接和销毁连接上；<strong>HTTP1.1</strong>则默认长连接，即建立一个TCP连接可以发送多条HTTP请求，减少了建立关闭连接的消耗。</p></li><li><p><strong>带宽优化</strong></p><p><strong>HTTP1.0</strong>不支持发送部分数据，例如只需要某个对象的一部分，而服务端却把真个对象都发送了过来，导致了带宽的浪费；HTTP1.0并且不支持断点续传。<strong>HTTP1.1</strong>在请求头引入Range头部，它允许只请求资源的一部分（返回码为206 partial content），并且支持断点续传，解决了1.0带宽浪费的问题。</p></li><li><p><strong>Host域头部</strong></p><p><strong>HTTP1.0</strong>中认为每台服务器都绑定一个唯一的IP地址，因此请求中并没有传递主机域（hostname）。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。<strong>HTTP1.1</strong>的请求消息的响应消息都支持host域，而且请求消息中没有host域会报错。</p></li><li><p><strong>HTTP1.0新增24个错误状态码</strong></p></li></ol><h3 id="HTTP2-0-和-HTTP1-x-的区别"><a href="#HTTP2-0-和-HTTP1-x-的区别" class="headerlink" title="HTTP2.0 和 HTTP1.x 的区别"></a>HTTP2.0 和 HTTP1.x 的区别</h3><ol><li><p><strong>二进制数据格式</strong></p><p><strong>HTTP1.x</strong>使用文本格式数据存在天然缺陷；<strong>HTTP2.0</strong>直接使用二进制格式数据，在应用层和传输层之间增加了一个二进制分帧层，在兼容HTTP1.x的基础上，改进传输性能，实现低延迟和高吞吐量。</p></li><li><p><strong>多路复用</strong></p><p><strong>HTTP2.0</strong>多路复用允许同时通过单一的TCP连接发送多重请求-响应消息。即使连接共享，提高连接的利用率，同个域名只需要占用一个TCP连接。<strong>HTTP1.1</strong>对同一域名的TCP并行连接数有限制一般为4~5个，超过限制则会阻塞，可以通过使用多个域名解决，但是会有很多TCP连接建立，由于拥塞控制，每个TCP刚建立会经历慢启动，会大大降低传输速度；还会产生多个TCP连接竞争带宽的情况。</p></li><li><p><strong>header压缩</strong></p><p><strong>HTTP1.x</strong> header中含有大量数据，并且每次发送请求都会重复发送；<strong>HTTP2.0</strong> 使用 HPACK 算法对header的数据进行压缩，通讯双方各自缓存一份 header fields 表，然后实行差量更新header，就只需要传输差量就行，这样就避免了重复传输。</p></li><li><p><strong>服务端推送</strong></p><p>服务端推送是一种在客户端请求之前发送数据的机制。</p><p>服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把 JS 和 CSS 文件推送给客户端保存到本地缓存，而不需要客户端解析 HTML 时再发送这些请求。</p></li></ol><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞控制是用来解决由网络拥塞引起的路由器缓存溢出而造成丢包的问题，主要原理是通过拥塞窗口控制发送方的发送速率达成的。</p><h3 id="拥塞控制的三种状态"><a href="#拥塞控制的三种状态" class="headerlink" title="拥塞控制的三种状态"></a>拥塞控制的三种状态</h3><p>超时的两种情况：1. 超时重传，ssthresh = cwnd / 2 , cwnd = 1MSS     2. 收到三个冗余ACK进入快速重传，ssthresh = cwnd / 2, cwnd = ssthresh + 3 MSS，尝试进入快速恢复一步到位</p><ol><li><p><strong>慢启动</strong> (进入条件：ssthresh = cwnd / 2; cwnd = 1MSS)</p><p>将拥塞窗口设置为1个MSS（最大报文段长度），初始发送速率为MSS/RTT；只要发送方每收到一个报文的确认拥塞窗口就增加一个MSS，窗口呈指数增长；慢启动结束的三个阶段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当收到一个由超时指示的丢包事件（即发生拥塞），发送方立即将ssthresh（慢启动阈值）设置为当前窗口的的一半，并将拥塞窗口重置为<span class="number">1</span>个<span class="variable constant_">MSS</span>，并重新执行慢启动。</span><br><span class="line"><span class="number">2.</span> 当在拥塞中慢启动等于ssthresh（慢启动阈值）时，还继续慢启动会有些鲁莽，所以转为拥塞避免阶段</span><br><span class="line"><span class="number">3.</span> 如果检测<span class="number">3</span>个冗余<span class="variable constant_">ACK</span>（当接收方接收到一个失序报文时，立即响应一个重复<span class="variable constant_">ACK</span>，在超时时间之前，提前告诉发送方，发送丢包事件，因为还能收到回复，证明拥塞没有超时那么严重），执行快速重传，并进入快速恢复阶段</span><br></pre></td></tr></table></figure></li><li><p><strong>拥塞避免</strong>（进入条件：cwnd = ssthresh）</p><p>进入拥塞避免时，拥塞窗口大小大约是上一次拥塞时值的一半，离拥塞并不遥远，所以应该谨慎增加拥塞窗口的大小；拥塞避免采用每个RTT只将cwnd增加一个MSS，即没收到一个ACK就将cwnd增加(MSS * MSS / cwnd)字节。</p><p>拥塞避免结束的两个阶段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当收到一个请求超时，设置发送方ssthresh=cwnd / <span class="number">2</span>，并且cwnd = <span class="number">1</span> <span class="variable constant_">MSS</span>，然后进入慢启动状态</span><br><span class="line"><span class="number">2.</span> 当收到三个冗余<span class="variable constant_">ACK</span>（发送丢包事件），设置发送方ssthresh = cwnd / <span class="number">2</span>, 并且cwnd = ssthresh + 3MSS (要加上三个冗余<span class="variable constant_">ACK</span>)，然后进入快速恢复状态</span><br></pre></td></tr></table></figure></li><li><p><strong>快速恢复</strong> (进入条件：ssthresh = cwnd / 2; cwnd = ssthresh + 3 MSS)</p><p>如果还会收到冗余ACK，就每收到一个冗余ACK就将cwnd增加一个MSS，</p><p>快重传和快恢复结束的两个阶段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当对丢失报文段的一个<span class="variable constant_">ACK</span>到达时，设置发送方cwnd = ssthresh 后进入拥塞避免状态</span><br><span class="line"><span class="number">2.</span> 当收到一个请求超时事件，ssthresh = cwnd / <span class="number">2</span>, cwnd = <span class="number">1</span> <span class="variable constant_">MSS</span>，之后进入慢启动状态</span><br></pre></td></tr></table></figure></li></ol><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><ul><li>Expires</li></ul><blockquote><p>响应头，代表该资源的过期时间，服务端和浏览器端可能有时差，不准确</p></blockquote><ul><li>Cache-Control</li></ul><blockquote><p>请求/响应头，缓存控制字段，精确控制缓存策略，主要子字段有 max-age 资源过期相对时间 和 no-cache 不使用强缓存；优先级比Expires高，只要有cache-control 就不判断 expires</p></blockquote><ul><li>If-Modified-Since</li></ul><blockquote><p>请求头，带上 上次服务端返回的 last-modified</p></blockquote><ul><li>Last-Modified</li></ul><blockquote><p>响应头，资源最近修改时间，由服务器告诉浏览器。</p></blockquote><ul><li>Etag</li></ul><blockquote><p>响应头，标识当前文件内容是否改变，是当前文件的唯一标识；解决了last-modified精确到秒（如果一秒钟修改多次检测不到）的问题，和 修改了文件但没有修改内容的问题 以及服务端不能精确得到文件的 last-modified 的值的问题</p></blockquote><ul><li>If-None-Match</li></ul><blockquote><p>请求头，发送上次服务端返回的 Etag文件是否修改的唯一标识 ，优先级比 if-modified-since 高，只要有 if-none-match 就不会去判断 if-modified-since</p></blockquote><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>通过服务端返回Expires 或 Cache-control 首部来设定，如果命中强缓存，浏览器会直接从本地缓存中读取数据，并返回 200 from memory/disk cache</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存通过客户端和服务端设置首部设定，设置Etag / If-None-Match，Last-Modified / If-Modified-Since 首部实现</p><h3 id="强缓存-和-协商缓存的工作"><a href="#强缓存-和-协商缓存的工作" class="headerlink" title="强缓存 和 协商缓存的工作"></a>强缓存 和 协商缓存的工作</h3><p>浏览器首先通过Expires 或 Cache-Control 验证是否命中强缓存，如果命中，则直接从本地缓存中读取数据，返回200；如果没有命中强缓存，则进入协商缓存阶段，发送 if-modified-since带有文件修改时间 和 if-none-match带有etag，如果没有修改就不返回文件返回304，浏览器就读取本地缓存；否则返回修改后的文件状态码200</p><h2 id="GET-和-POST的区别"><a href="#GET-和-POST的区别" class="headerlink" title="GET 和 POST的区别"></a>GET 和 POST的区别</h2><ol><li>GET参数通过url传递；POST参数放在请求体中</li><li>GET请求在url中存放的参数是有长度限制的（一般为2k）；POST则没有</li><li>GET请求只能进行url编码；POST请求可以多种编码（form-data、urlencoded、json、xml）</li><li>GET请求会被浏览器主动缓存，留下历史记录；POST则不会</li><li>GET产生一个TCP报文；POST产生两个TCP报文，对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li></ol><h2 id="服务器状态码"><a href="#服务器状态码" class="headerlink" title="服务器状态码"></a>服务器状态码</h2><ul><li><p>1xx：表示目前是协议的中间状态，还需要后续请求</p><p>100 Continue，post请求发送的第一个只包含header的报文，服务端响应 100 Continue 表示继续发送后续请求</p></li><li><p>2xx：表示请求成功</p><p>200 OK 正常返回</p><p>201 Created 请求成功并且服务器创建了新的资源</p><p>202 Accept 服务端接收到了请求，但尚未处理</p><p>204 No Content 服务端没有返回内容</p><p>206 Partial Content 服务端返回某个对象的部分内容</p></li><li><p>3xx：表示重定向状态，需要重新请求</p><p>301 Moved Permanently 请求对象永久重定向到新的位置，需要把原来保存的uri更新成新的uri（虽然浏览器规定不会从POST变成GET，但是实际运用中并没有遵守） </p><p>302 Found 临时重定向，表示这个资源只是暂时不能访问，希望用户本次使用新的URI，但是过一段时间后，可以正常访问；一般是访问某个网页需要权限，然后临时重定向到登录页面，登录后就可以继续访问（虽然浏览器规定不会从POST变成GET，但是实际运用中并没有遵守）</p><p>303 See Other 临时重定向，和302状态码很相似，不过明确表明了应使用GET方法定向获取资源</p><p>304 Not Modified 协商缓存命中返回的状态码</p><p>307 Temporary Redirect 临时重定向，与302很相似，严格遵照浏览器标准，不会从POST变成GET；</p></li><li><p>4xx：客户端错误状态码</p><p>400 Bad Requst 表示请求报文中存在语法错误。</p><p>401 Unauthorized 表示发送的请求需要通过HTTP认证</p><p>403 Forbidden 表示未获得文件访问权限，服务端拒绝对该资源的访问</p><p>404 Not Found 表示服务器上没有所请求的资源</p><p>405 Method Not Allowed 表示服务器禁止使用该方法请求</p></li><li><p>5xx：服务器端错误</p><p>500 Internal Server Error 表示服务端在响应请求时发生错误</p><p>502 Bad Gateway 表示扮演网关 或 代理 的服务器，从上游服务器接收到的响应式无效的</p><p>503 Service Unavailable 表示服务器 过载 或 维护 暂时无法处理请求</p></li></ul><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack是一个模块打包器、支持code-splitting、模块化。。。</p><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>参与webpack打包流程的插件，可以参与到webpack的各个生命周期中。</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>识别webpack不认识的模块，并解析模块</p><h2 id="tree-shaking-摇树优化"><a href="#tree-shaking-摇树优化" class="headerlink" title="tree-shaking 摇树优化"></a>tree-shaking 摇树优化</h2><p>摇树优化是指在打包中，去除那些引入了，但是未被使用的模块。</p><h2 id="HMR-模块热更新"><a href="#HMR-模块热更新" class="headerlink" title="HMR 模块热更新"></a>HMR 模块热更新</h2><p>HMR能够在不刷新页面的情况下，动态替换资源模块。</p><h3 id="开启HMR"><a href="#开启HMR" class="headerlink" title="开启HMR"></a>开启HMR</h3><ol><li>配置 <code>devServer.hot</code> 属性为 true</li><li>在js中使用 <strong>module.hot.accept</strong>(模块标识，模块包含函数)</li></ol><h3 id="css实现HMR"><a href="#css实现HMR" class="headerlink" title="css实现HMR"></a>css实现HMR</h3><p><code>style-loader</code> 内置 Css 模块热更</p><h3 id="vue实现HMR"><a href="#vue实现HMR" class="headerlink" title="vue实现HMR"></a>vue实现HMR</h3><p><code>vue-loader</code> 内置 Vue 模块热更</p><h2 id="hash、chunkHash、contentHash"><a href="#hash、chunkHash、contentHash" class="headerlink" title="hash、chunkHash、contentHash"></a>hash、chunkHash、contentHash</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211206233913215.png" alt="image-20211206233913215"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125102026563.png" alt="image-20211125102026563"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125102543200.png" alt="image-20211125102543200"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125102610900.png" alt="image-20211125102610900"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125103837621.png" alt="image-20211125103837621"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125103945898.png" alt="image-20211125103945898"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125104512231.png" alt="image-20211125104512231"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125105003941.png" alt="image-20211125105003941"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125110321679.png" alt="image-20211125110321679"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125110419880.png" alt="image-20211125110419880"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125110649948.png" alt="image-20211125110649948"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125110744522.png" alt="image-20211125110744522"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125110908461.png" alt="image-20211125110908461"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125112252655.png" alt="image-20211125112252655"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125113248113.png" alt="image-20211125113248113"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125113718819.png" alt="image-20211125113718819"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125113723979.png" alt="image-20211125113723979"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125134718285.png" alt="image-20211125134718285"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125135313468.png" alt="image-20211125135313468"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126224046052.png" alt="image-20211126224046052"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126225631011.png" alt="image-20211126225631011"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126230224713.png" alt="image-20211126230224713"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126230512406.png" alt="image-20211126230512406"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126232721501.png" alt="image-20211126232721501"></p><h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126231534955.png" alt="image-20211126231534955"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126231545376.png" alt="image-20211126231545376"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211127094049007.png" alt="image-20211127094049007"></p><h2 id="提取vue-cli-webpack配置"><a href="#提取vue-cli-webpack配置" class="headerlink" title="提取vue-cli webpack配置"></a>提取vue-cli webpack配置</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211127101511107.png" alt="image-20211127101511107"></p><h2 id="vue-cli配置image-webpack-loader"><a href="#vue-cli配置image-webpack-loader" class="headerlink" title="vue-cli配置image-webpack-loader"></a>vue-cli配置image-webpack-loader</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">      <span class="attr">rules</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">          <span class="attr">use</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">loader</span>: <span class="string">&#x27;image-webpack-loader&#x27;</span>,</span><br><span class="line">              <span class="attr">options</span>: &#123;</span><br><span class="line">                <span class="attr">mozjpeg</span>: &#123;</span><br><span class="line">                  <span class="attr">progressive</span>: <span class="literal">true</span>,</span><br><span class="line">                  <span class="attr">quality</span>: <span class="number">50</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">                <span class="attr">optipng</span>: &#123;</span><br><span class="line">                  <span class="attr">enabled</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">pngquant</span>: &#123;</span><br><span class="line">                  <span class="attr">quality</span>: [<span class="number">0.5</span>, <span class="number">0.65</span>],</span><br><span class="line">                  <span class="attr">speed</span>: <span class="number">4</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">gifsicle</span>: &#123;</span><br><span class="line">                  <span class="attr">interlaced</span>: <span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ts"><a href="#ts" class="headerlink" title="ts"></a>ts</h1><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126113627319.png" alt="image-20211126113627319"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126113805425.png" alt="image-20211126113805425"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211126114032648.png" alt="image-20211126114032648"></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是用来限制类或对象的结构的规范</p><h1 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h1><h2 id="koa-router使用"><a href="#koa-router使用" class="headerlink" title="koa-router使用"></a>koa-router使用</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211201220837840.png" alt="image-20211201220837840"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211201221220198.png" alt="image-20211201221220198"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面经汇总</title>
    <link href="https://fanned1.github.io/posts/undefined.html"/>
    <id>https://fanned1.github.io/posts/undefined.html</id>
    <published>2022-11-09T16:26:54.352Z</published>
    <updated>2022-11-10T07:09:27.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面经汇总"><a href="#面经汇总" class="headerlink" title="面经汇总"></a>面经汇总</h1><h2 id="1-JavaScript-基础知识"><a href="#1-JavaScript-基础知识" class="headerlink" title="1.JavaScript 基础知识"></a>1.JavaScript 基础知识</h2><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><ul><li>事件流就是当页面中元素触发了某个事件后，事件触发的顺序，称作事件流</li><li>事件流有三个阶段，分别是<ul><li>捕获阶段<ul><li>首先事件从 window，然后依次往内层元素捕获，直到触发到目标事件为止</li></ul></li><li>目标阶段<ul><li>当从捕获阶段找到触发事件的元素后，就会执行目标元素对应的事件处理函数</li></ul></li><li>冒泡阶段<ul><li>当经过目标阶段后，事件从目标元素向外层寻找，如果遇到对应的处理事件就会触发对应的函数，直到寻找到 window 为止</li></ul></li></ul></li><li>DOM0 级事件模型和 DOM2 级事件模型<ul><li>DOM0 级事件模型是浏览器早期的事件模型，它将事件监听绑定到 dom 对象对应的一些属性身上，例如 el.onclick、el.onmouseover 等等，这种事件绑定只能为同类型的事件绑定一个处理函数，如果再次绑定，会覆盖掉之前设置的处理函数</li><li>DOM2 级事件模型就是上述事件流，它使用的是 addEventListener 函数来添加事件监听，使用 removeEventListener 函数来移除事件监听，DOM2 级事件模型可以为同一个元素的同一类事件绑定多个事件处理函数，处理函数的执行顺序按照绑定的顺序执行</li></ul></li><li>为什么没有 DOM1 级事件模型<ul><li>因为在 DOM1 级标准中，并没有对事件的相关内容作定义</li></ul></li></ul><h3 id="js-垃圾回收机制"><a href="#js-垃圾回收机制" class="headerlink" title="js 垃圾回收机制"></a>js 垃圾回收机制</h3><ul><li>什么是垃圾<ul><li>当一个变量或对象没有被引用时，这个变量或者对象就是垃圾</li></ul></li><li>如何回收垃圾<ul><li>最开始将所有变量都做上标记</li><li>垃圾回收器会遍历所有的根节点，然后删除遍历到的对象的标记，直到遍历完过后，那些有标记的对象就是垃圾，然后对这些垃圾进行回收处理</li></ul></li><li>垃圾回收机制是如何优化的，怎么提升的垃圾回收效率和速度<ul><li>在运行环境中，其实主要有两部分的对象，一部分是临时的对象，比如函数作用域中定义的变量，还有一部分是比较长久的对象，比如 window、DOM 等等，如果每次垃圾回收都对这些对象进行处理的话，那么就会降低垃圾回收的效率</li><li>在 V8 引擎中，就为这两类对象提供了不同的垃圾回收机制，这种回收机制叫做分代回收<ul><li>为临时对象创建一个专门的堆空间，叫做新生代，新生代由副垃圾回收器管理</li><li>为长久对象创建一个专门的堆空间，叫做老生代，老生代由主垃圾回收器管理</li><li>副垃圾回收器管理的工作原理<ul><li>新生代中分了两个区，一个是对象区，一个是空闲区</li><li>每次有临时对象的加入，都会被添加到新生代中的对象区中去，当对象区要满的时候，进行标记清除，然后将有效的对象复制到空闲区中，并且会将它们有序的排列</li><li>最后清理对象区中的垃圾，然后通过对调，将空闲区的活动对象交换到对象区中，此时对象区就是有效的并且有序的对象</li><li>如果发现一个对象进行了多次交换，那么会将这个对象认为是长久对象，然后将它交由老生代区管理</li></ul></li><li>主垃圾回收器的工作原理<ul><li>进行标记清除，然后再将不连续的对象空间进行整理</li></ul></li></ul></li><li>增量回收<ul><li>将回收工作分成很多小块，每次执行一部分</li></ul></li></ul></li></ul><h3 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h3><ul><li><p>什么是闭包</p><ul><li>闭包就是存储在函数中的<strong>一组对象</strong></li></ul></li><li><p>那闭包对象中存储的是什么呢</p><ul><li>这组对象主要负责存储上级作用域的变量，本来上级作用域消失的时候，上级作用域中的变量也会随即被释放，但是，由于 js 的特性，是可以嵌套定义函数的，在上级作用域内定义的函数如果在上级作用域释放之后还需要保留，并且这个函数还使用了上级作用域中的变量，那么此时就是将这些还需要用到的变量保存到内部函数的闭包对象之中，每个闭包对象对应着它们的作用域（意思是会为每个变量被保留的作用域创建一个闭包对象）</li></ul></li><li><p>闭包有什么用</p><ul><li><p>可以用来私有化变量，当一个函数需要一个全局变量来保存数据时，但是全局其实并不需要这个变量，那么就可以利用闭包，比如防抖的例子</p></li><li><p>```javascript<br>function deBounce() {<br>  var timer<br>  return function () {</p><pre><code>clearTimeout(timer)timer = setTimeout(function () &#123;  // 执行的操作&#125;, 1000)</code></pre><p>  }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在的 deBounce 函数中，就返回了一个函数，然后这个函数使用了 deBounce 中的 timer，那么这个返回的函数就会将 timer 保存在它的闭包中，外面的代码就不能访问到这个 timer，实现了变量私有化，避免了一些全局的污染</span><br><span class="line"></span><br><span class="line">### 如何判断一个变量是数组</span><br><span class="line"></span><br><span class="line">- 使用 instanceof，如果是数组，例如 a instanceof Array</span><br><span class="line">- 使用 Object.prototype.toString.call()，例如 Object.prototype.toString.call(a) == &#x27;[object Array]&#x27;</span><br><span class="line">- 注意，不能使用 typeof 来判断，因为 typeof 获取数组类型，得到的是字符串&#x27;object&#x27;</span><br><span class="line"></span><br><span class="line">### 实现柯里化</span><br><span class="line"></span><br><span class="line">- 柯里化就是将一个本来需要传入多个参数的函数，转换成每次只传入一个参数，然后返回一个函数，继续传入下一个参数，可以达到参数复用的效果，如 sum(1, 2)变成 sum(1)(2)</span><br><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  function processCurrying(fn, arg) &#123;</span><br><span class="line">    var _this = this</span><br><span class="line">    var len = fn.length</span><br><span class="line">    arg = arg || []</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">      // 合并所有参数</span><br><span class="line">      Array.prototype.push.apply(arg, Array.prototype.slice.call(arguments))</span><br><span class="line">      if (arg.length &lt; len) &#123;</span><br><span class="line">        // 如果参数不足，则继续收集</span><br><span class="line">        return processCurrying.call(_this, fn, arg)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 参数足够，返回结果</span><br><span class="line">      return fn.apply(_this, arg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>主要点就在于参数收集，如果参数不足，就继续递归调用，收集参数，如果参数达到原本函数的收集要求，那么就直接调用函数，返回最终的结果</p></li></ul><h2 id="2-JavaScript-高级知识"><a href="#2-JavaScript-高级知识" class="headerlink" title="2.JavaScript 高级知识"></a>2.JavaScript 高级知识</h2><h2 id="3-浏览器和网页知识"><a href="#3-浏览器和网页知识" class="headerlink" title="3.浏览器和网页知识"></a>3.浏览器和网页知识</h2><h3 id="浏览器输入-URL-到页面呈现经历了什么"><a href="#浏览器输入-URL-到页面呈现经历了什么" class="headerlink" title="浏览器输入 URL 到页面呈现经历了什么"></a>浏览器输入 URL 到页面呈现经历了什么</h3><ul><li>首先根据 url 地址，判断是否存在强缓存机制，如果存在，并且缓存有效，那么直接使用强缓存，不会再发送请求</li><li>根据域名解析出 ip 地址，解析步骤有查找浏览器缓存-&gt;查看主机缓存-&gt;查找 hosts 文件-&gt;进行 DNS 查询</li><li>三次握手，建立 tcp 连接，如果是 https 协议，还是建立对应的 ssl 连接，建立安全的传输通道</li><li>连接建立成功后，浏览器发送 http 或 https 请求</li><li>客户端收到请求后，如果存在协商缓存机制，进行协商缓存的判断，如果资源没有改变，则直接返回 304 状态码，让浏览器使用本地缓存，否则返回对应的数据</li><li>浏览器接收到数据后，对 html 进行解析，构造对应的 dom 树，在解析 html 过程中可能存在 js 文件，这时会停止解析，优先下载和解析 js 文件，还有解析 css 文件，构造 css 规则树，等 dom 树和 css 树构建完之后，将两个树合并构建渲染树，然后按一定规则，对渲染树进行布局（如盒子的尺寸和位置的计算），这个过程叫做重排，也叫文档回流，然后就是对颜色等样式信息进行计算，这个过程叫做重绘，最后交由 GPU 处理渲染，然后将页面呈现到显示器上</li></ul><h3 id="JS-文件执行顺序和页面渲染有什么关系吗"><a href="#JS-文件执行顺序和页面渲染有什么关系吗" class="headerlink" title="JS 文件执行顺序和页面渲染有什么关系吗"></a>JS 文件执行顺序和页面渲染有什么关系吗</h3><ul><li>通常 JS 代码会改变 DOM 树的结构，所以浏览器在解析 HTML 时如果遇到 JS 则会停下来先去执行 JS 文件再继续解析 HTML，这就可能会导致加载白屏。</li></ul><h3 id="XSS、CSRF-介绍一下"><a href="#XSS、CSRF-介绍一下" class="headerlink" title="XSS、CSRF 介绍一下"></a>XSS、CSRF 介绍一下</h3><ul><li><p><strong>XSS 全称 cross-site scripting（跨站点脚本）</strong>，是一种<strong>代码注入攻击</strong>，是当前 web 应用中最危险和最普遍的漏洞之一。<strong>攻击者向网页中注入恶意脚本，当用户浏览网页时，脚本就会执行，进而影响用户</strong>，比如关不完的网站、盗取用户的 cookie 信息从而伪装成用户去操作，危害数据安全。</p></li><li><p><strong>CSRF 跨站请求伪造</strong>（英语：Cross-site request forgery），是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如：</p><p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p></li></ul><h3 id="什么是-http-和-https"><a href="#什么是-http-和-https" class="headerlink" title="什么是 http 和 https"></a>什么是 http 和 https</h3><ul><li>http 就是超文本传输协议，它是基于请求和响应的模式，具有无连接、无状态、便捷等特点。</li><li>https 是 http 和 ssl 的结合，因为 http 其实是不安全的，因为 http 是明文传输数据，所以攻击者可以很轻易的拿到 http 请求的数据，所以 https 对 http 采用 ssl 加密，来保证安全性。</li></ul><h3 id="https-加密传输过程"><a href="#https-加密传输过程" class="headerlink" title="https 加密传输过程"></a>https 加密传输过程</h3><ul><li>首先，https 传输是需要服务器认证相应的 CA 证书机构，当认证后，服务器就会得到 CA 机构颁发的数字证书</li><li>浏览器向服务器发起请求，并携带上浏览器拥有的加密算法，供服务器选择</li><li>服务器此时会返回一个数字证书、数字签名（用 CA 机构的私钥加密后的数字证书）和选择的加密算法。</li><li>浏览器收到数字证书后，会对数字证书的内容进行验证，进行证书内容是否过期等检验，然后会利用 CA 机构的公钥对数字签名进行解密（数字签名解密后其实就是数字证书），然后利用解密后的内容和数字证书进行对比，如果有任何差错，就会拒绝本次连接。</li><li>此时就会利用服务器选择的加密算法，生成一组随机数（这组随机数就是对称加密的密钥），然后利用 CA 证书中的公钥对生成的密钥进行加密，传送给服务器。</li><li>服务器再利用 CA 证书中的私钥，对加密传输过来的秘钥进行解密，之后服务器和浏览器就会通过这对密钥对传输的数据进行加密和解密。</li></ul><h3 id="什么是-websocket，和-http-有什么不同"><a href="#什么是-websocket，和-http-有什么不同" class="headerlink" title="什么是 websocket，和 http 有什么不同"></a>什么是 websocket，和 http 有什么不同</h3><ul><li>http 是请求和相应模式的协议，但是在 http 中，每建立的一个连接，只能进行一次请求和响应，虽然在 http1.1 中加入和 keep-alive，使得 http 可以在一次连接中进行多次请求和响应，但是一个响应就对应者一个请求（服务器是不能主动向客户端发送请求的），即响应是被动的状态</li><li>websocket 是基于 http 协议实现的，他们建立连接的方式一样，也是采用三次握手，但是在 websocket 中响应可以是主动的，也就是不需要客户端向服务器发起请求，服务器也能向客户端发送信息</li></ul><h3 id="http-的请求方法和应用场景"><a href="#http-的请求方法和应用场景" class="headerlink" title="http 的请求方法和应用场景"></a>http 的请求方法和应用场景</h3><ul><li>GET<ul><li>数据直接放在 url 的后面</li><li>一般用于请求数据使用</li></ul></li><li>POST<ul><li>数据放在请求体 body 中</li><li>一般在提交表单，或者上传一些保密的数据使用</li><li>POST 数据发送分为两个阶段，第一阶段先发送 header，等待服务器响应 100 后，再发送 data</li></ul></li></ul><h3 id="http2-与-http1-1-的区别"><a href="#http2-与-http1-1-的区别" class="headerlink" title="http2 与 http1.1 的区别"></a>http2 与 http1.1 的区别</h3><ul><li>http2 采用了多路复用技术，提高了信息传输的速度，提高资源利用率</li><li>使得一个连接可以并发发出多个请求</li><li>为什么 HTTP1.1 中不能实现多路复用呢？<ul><li>因为 HTTP2 是基于二进制“帧”的协议，而 HTTP1.1 是基于“文本分割”解析的协议</li><li>在 HTTP1.1 的文本分割中，数据会被分割成多条内容，每条内容会有指定的分隔符，所以在服务器接收信息的时候，是以不断读取字符的方式接收信息，直到读取到了规定的分隔符，代表一条数据读取完毕，如果在这种情况下使用多路复用（即不同的数据一起传输），那么服务器无法辨别哪一个段属于哪一条数据，就会产生错误。</li></ul></li><li>那为什么”数据帧“的方式传输就能多路复用呢？<ul><li>因为在数据帧中，包含了许多关于数据的信息，比如数据的长度，所属数据的标识等等，通过这些信息，服务器便可知道数据帧是属于哪个完整数据的，就可以实现交错传递和多路复用，而不是单一传递一种数</li></ul></li></ul><h3 id="同源策略和跨域的理解"><a href="#同源策略和跨域的理解" class="headerlink" title="同源策略和跨域的理解"></a>同源策略和跨域的理解</h3><ul><li><p>同源策略是浏览器作出的安全策略</p></li><li><p>同源策略只两个地址它们的协议、域名、端口号都相同，则为同源，否则就是跨域</p></li><li>在非同源的情况下，是不能读取 cookie、dom，ajax 请求也不能跨域发送，这能有效阻止跨站攻击</li><li><p>如何进行跨域的请求</p><ul><li><p>第一种可以利用 script 标签的请求机制，因为 script 标签请求 js 脚本是不受同源策略限制的，也就是可以发起跨域的脚本请求，基于这种条件下，在利用 script 标签请求指定路径时，附带上一个处理函数，在传送到服务器时，服务器会利用需要的数据对这个处理函数进行包装，最后返回给客户端去执行，这种方式称为<strong>JSONP</strong></p></li><li><p>第二种是利用<strong>CORS</strong>跨域，全称<strong>跨域资源共享</strong>（Cross-origin resource sharing），CORS 需要浏览器和服务器同时支持，在浏览器支持的情况下，浏览器会自动处理跨域请求，并在请求头中加入 origin 字段，而对于服务器，只需要在响应头中设置<strong>Access-Control-Allow-Origin</strong>字段，即设置允许跨域访问的请求源，就可以实现跨域资源共享</p></li><li><p>还有一种跨域页面传递消息，postMessage，可以让父子页面进行通信</p><ul><li><p>```js<br>// 父页面<br>var iframe = document.getElementById(‘iframe’)<br>iframe.contentWindow.postMessage(‘数据内容’, ‘*’)</p><p>// 子页面<br>window.addEventListener(‘message’, function (e) {<br>  // e中三个重要数据<br>  // e.data 发送过来的数据<br>  // e.origin 发送消息的源，协议+地址+端口号<br>  // e.source 发送消息的窗口对象<br>})</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    -</span><br><span class="line"></span><br><span class="line">### cookie、sessionStorage、localStorage、indexDB 的区别</span><br><span class="line"></span><br><span class="line">- 首先它们的共同点是都存储在浏览器，并且只有同源地址才可以访问</span><br><span class="line"></span><br><span class="line">- sessionStorage 和 localStorage 都是 webStorage 的内容，是 HTML5 的标准，它们都是存储在客户端，是不与服务器交互的数据，并且存储大小可达 5MB</span><br><span class="line"></span><br><span class="line">- cookie 则是会与服务器有数据交换的，存储大小只有 4KB，因为请求头中是可以携带 cookie 到服务器，而响应头中可以设置 cookie，所以对于只在本地使用的数据，建议使用 webStorage 来存储</span><br><span class="line"></span><br><span class="line">- indexDB 作为一个本地数据库，又更强大的功能，能建立索引，类似于一个非关系数据库，存储大小没有限制</span><br><span class="line"></span><br><span class="line">### cookie 中属性的作用</span><br><span class="line"></span><br><span class="line">- expires</span><br><span class="line">  - 用于设置 cookie 的过期时间，时间格式为 GMT</span><br><span class="line">- domian 和 path</span><br><span class="line">  - domain 设置的 cookie 有效的域，可以是二级域名，也可以是三级域名，如www.baidu.com或baidu.com</span><br><span class="line">  - path 设置的是 cookie 有效的路径，如/，/home 等</span><br><span class="line">  - 当设置了 doamin 和 path 属性时，只有指定域和路径下的网页才可以访问到这个 cookie，才会将这个 cookie 在发送请求时携带</span><br><span class="line">  - domain 默认为当前访问的网页的域名，path 为当前访问网页所在的路径</span><br><span class="line">- secure</span><br><span class="line">  - 只有当请求是 https 时，才会将 cookie 携带，发送到服务器</span><br><span class="line">- httpOnly</span><br><span class="line">  - 这个属性用于限制 js 访问 cookie，如果服务器在响应头中设置 cookie 时添加了这个属性，那么当这个 cookie 添加到浏览器后，js 脚本是访问不到这个 cookie 的</span><br><span class="line">  - 所以在客户端是不能设置带 httpOnly 属性的 cookie 的</span><br><span class="line">- samesite</span><br><span class="line">  - 用于限制 cookie 在跨站请求是是否被携带</span><br><span class="line">  - 属性值</span><br><span class="line">    - Strict 完全禁止第三方 cookie，在跨站情况下绝对不会携带 cookie</span><br><span class="line">    - Lax 允许第三方请求携带 cookie</span><br><span class="line">    - None 无论是否跨站都携带 cookie</span><br><span class="line"></span><br><span class="line">### html 中的 DOCTYPE</span><br><span class="line"></span><br><span class="line">- 在过去的 html 有严格模式和混杂模式区分</span><br><span class="line">  - 严格模式：按照浏览器的最高标准进行页面渲染</span><br><span class="line">  - 混杂模式：根据实际情况进行向下兼容的渲染</span><br><span class="line">- html5 中没有 DTD，所以就没有严格模式和混杂模式的区分</span><br><span class="line"></span><br><span class="line">### 强缓存和协商缓存</span><br><span class="line"></span><br><span class="line">- 强缓存</span><br><span class="line">  - 指在请求页面或资源时，如果之前访问后添加了强缓存，那么如果在缓存时间没有过期的情况下，会直接从缓存中读取资源，而不会从服务器获取</span><br><span class="line">  - 但是如果刷新页面，那么会正常发送请求，去获取服务器上的资源</span><br><span class="line">- 协商缓存</span><br><span class="line">  - 在第一次请求页面后，会在响应头中返回两个相关信息，一个是 etag，一个是 modified，etag 代表资源的唯一编号，如果资源被修改了，那么这个编号也会改变，modified 代表资源最后修改的时间</span><br><span class="line">  - 在后续的请求页面中，如果之前请求过设置了协商缓存的资源，那么在后面的请求头中带上之前的 etag 和 modified 字段，当访问服务器后，会用服务器最新资源的 etag 和请求头中的 etag 对比，如果相同，则直接返回一个 304 状态码的响应，代表资源未更新，客户端将会从缓存获取这个资源，如果对比后发现 etag 不同，则代表资源已经更新，这是会将最新的资源和最近 etag 和 modified 返回，且状态码为 200</span><br><span class="line">- 如何设置强缓存</span><br><span class="line">  - 在响应头中设置`cache-control`字段，字段内容如下</span><br><span class="line">    - `max-age` 指定缓存过期时间 格式：max-age=123，单位为秒</span><br><span class="line">    - `public` 资源可以为客户端和代理服务器缓存</span><br><span class="line">    - `private` 资源只能被客户端缓存</span><br><span class="line">    - `immutable` 设置后，进行刷新操作也不会重新请求，只有当 max-age 过期之后，才会重新发起请求</span><br><span class="line">    - `no-cache` 跳过强缓存，而走使用协商缓存</span><br><span class="line">    - `no-store` 不使用缓存，这时服务器和客户端就都不会缓存</span><br><span class="line">    - 选择多个属性用 ‘,’拼接，如：max-age=123, public, immutable</span><br><span class="line">  - 第二种是设置`expires`，但是`cache-control`比`expires`优先级要高</span><br><span class="line">- 如何设置协商缓存</span><br><span class="line">  - 在响应头中设置 etag 和 modified 字段</span><br><span class="line">  - 在请求头携带是名称有点不一样</span><br><span class="line">    - `etag`在请求头中为 `if-none-matched`</span><br><span class="line">    - `modified`在请求头中为`if-modified-since`</span><br><span class="line"></span><br><span class="line">### 重排（回流）和重绘</span><br><span class="line"></span><br><span class="line">- 什么是重排和重绘</span><br><span class="line"></span><br><span class="line">  - 当浏览器收到了请求回来的 html 和 css 文件之后，浏览器会对这两种文件进行解析，解析 html 文件来创建 DOM 树，解析 css 文件来创建样式树（CSSOM），然后将这两种树合并起来，形成一个渲染树，然后由渲染树计算布局的位置，尺寸等信息，这个构造过程过程，就叫做重排，随后需要根据渲染进行绘制，然后显示到屏幕上，这个过程就叫做重绘</span><br><span class="line"></span><br><span class="line">- 什么时候会重排和重绘</span><br><span class="line"></span><br><span class="line">  - 当元素的几何属性改变时，这时就会造成重排，几何属性就是这个属性影响着整体的布局，如果这个属性改变，可能就会影响其他元素的改变，所以这时需要重排，那么重排之后，肯定就会造成重绘</span><br><span class="line">  - 但是当修改元素的样式时，比如修改颜色等操作，这种是绝对不会影响其他元素布局的，所以只会造成重绘，不会造成重排</span><br><span class="line">  - 所以发生重排一定会重绘，重绘不会造成重排</span><br><span class="line"></span><br><span class="line">- 如何优化重排</span><br><span class="line"></span><br><span class="line">  - 当改变元素的几何属性，就会发生重排，如果多次修改，那么就会发生多次重排，所以我们可以把多次修改属性整合到一次修改，那么就只会发生一次重排了</span><br><span class="line"></span><br><span class="line">    - 比如原本是这样的</span><br><span class="line"></span><br><span class="line">    - ```javascript</span><br><span class="line">      // javascript</span><br><span class="line">      var el = document.querySelector(&#x27;.el&#x27;)</span><br><span class="line">      el.style.borderLeft = &#x27;1px&#x27;</span><br><span class="line">      el.style.borderRight = &#x27;2px&#x27;</span><br><span class="line">      el.style.padding = &#x27;5px&#x27;</span><br></pre></td></tr></table></figure></li><li><p>然后我们把这三个操作合并到一起</p></li><li><p>```javascript<br>var el = document.querySelector(‘.el’)<br>el.style.cssText = ‘border-left: 1px; border-right: 2px; padding: 5px’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 这样，就会减少重排，当然最好的还是更换元素的类选择器，来达到一次性修改样式的目的</span><br><span class="line"></span><br><span class="line">  - 那如果是同时添加多个 DOM 元素呢，那该如何解决，其实我们可以将要添加元素的父元素脱离文档，使它暂时不会影响文档的其他元素，这样，在这个元素中添加其他元素，也就不会每次添加都导致页面的重排</span><br><span class="line"></span><br><span class="line">    - 脱离文档的方法有多种</span><br><span class="line">    - 第一种可以将父元素设置 display: none，然后将元素添加到父元素中，等添加完之后，在将父元素 display: block，这样无论添加多少个子元素，都只会造成两次重排，一次是隐藏，一次是显示</span><br><span class="line">    - 第二种可以利用文档碎片，先把要添加的元素添加到文档碎片中，然后再把文档碎片添加到父元素中，这样只会造成一次页面重排，是比较好的一种方案</span><br><span class="line"></span><br><span class="line">  - 还有一种就是对`offsetTop，offsetLeft，scrollTop，clientTop`等待属性进行获取时，因为这些属性都具有实时性，所以浏览器不得不将页面进行重排，然后实时返回这些属性的相关信息</span><br><span class="line"></span><br><span class="line">    - 所以要使用这类属性的时候，应该用一个变量先保存，之后使用这个变量即可，而不是每次都去获取这个属性，从而造成浏览器的多次重排</span><br><span class="line"></span><br><span class="line">### 浏览器组成</span><br><span class="line"></span><br><span class="line">- 浏览器主进程</span><br><span class="line">  - 浏览器的主要管理进程，负责浏览器中所有操作的管理</span><br><span class="line">- GPU 进程</span><br><span class="line">  - 负责管理 GPU 渲染</span><br><span class="line">- 插件进程</span><br><span class="line">  - 当浏览器启用插件时，会为每个插件创建一个插件进程</span><br><span class="line">- 渲染进程（浏览器会为每个 tab 页面床架渲染进程，因为页面之间是独立的）</span><br><span class="line">  - GUI 线程</span><br><span class="line">    - 负责 HTML、CSS 代码的解析和渲染</span><br><span class="line">  - js 线程</span><br><span class="line">    - js 的主线程，负责执行 js 代码</span><br><span class="line">  - 事件管理线程</span><br><span class="line">    - 用于管理 js 中的异步任务，事件循环机制就是在此管理的</span><br><span class="line">  - 定时器线程</span><br><span class="line">    - 用于将有结果的定时器的回调函数，推入事件循环的任务队列中</span><br><span class="line">  - 请求线程</span><br><span class="line">    - 管理 ajax 请求，当 ajax 请求返回时，也会将请求的处理函数交由事件循环来管理</span><br><span class="line"></span><br><span class="line">### 为什么 inline-block 元素之间会有一个空隙</span><br><span class="line"></span><br><span class="line">- 往往在页面布局的时候，两个元素之间会换行，浏览器在解析行内元素的时候，会将这个换行当成一个空白符来解析，当 font-size 不为 0 时，这个空白符就会有一定的宽度，所以就出现了我们看到的空隙</span><br><span class="line"></span><br><span class="line">### CDN 加速（Content Delivery Network 内容分发网络）</span><br><span class="line"></span><br><span class="line">- CDN 加速是利用多个分布在网络中的缓存服务器，让用户以尽量快的速度访问到最近的资源，达到提高页面加载速度的目的</span><br><span class="line">- CDN 加速的具体流程</span><br><span class="line">  - 首先得有一台 CDN 专用的 DNS 服务器，和若干台缓存服务器</span><br><span class="line">  - 当浏览器对 URL 请求时，这台专用的 DNS 服务器会解析域名地址，找到对应的负载均衡设备</span><br><span class="line">  - 负载均衡设备会根据请求的 URL 解析出的 IP 地址，选择一个距离最近的服务器，或者根据请求的资源，找到拥有资源的服务器，或者根据服务器的负载情况，选择一台服务器，最终会结合以上三种情况，找到一个合适的缓存服务器，最后将缓存服务器的 ip 返回给浏览器</span><br><span class="line">  - 浏览器后续就会根据缓存服务器提供的 ip 地址，当请求指定资源时，就会向这台缓存服务器请求，达到提高加载速度的目的</span><br><span class="line">  - 有一种特殊情况，有可能负载均衡设备返回的缓存服务器并没有请求的资源，此时缓存服务器会一直向上级的缓存服务器请求，直到找到资源为止，如果缓存服务器都没有，最终会请求到源服务器</span><br><span class="line"></span><br><span class="line">1.</span><br><span class="line"></span><br><span class="line">## 4.CSS</span><br><span class="line"></span><br><span class="line">### `link`和`@import`的区别</span><br><span class="line"></span><br><span class="line">- `link`是在加载页面时同时加载对应的文件，而`@import`是在页面加载完毕后才加载</span><br><span class="line">- `link`引入的样式权重大宇`@import`引入的</span><br><span class="line">  - 原因其实就是在于`@import`的定义，`@import`只能定义在除`@charset`以外所有 CSS 规则的上方，否则会被浏览器给忽略，那么久可以理解为，`@import`加载进来的样式会放在当前文件 CSS 规则的最顶部，也就是为什么`link`的文件中样式会覆盖`@import`中的样式</span><br><span class="line">  - 那么为什么`@import`比`link`后加载，还会被覆盖呢？因为后加载依然会触发浏览器对 DOM 和 CSS 的渲染，浏览器最终会按照 CSS 的规则顺序进行渲染，就是因为`@import`加载的 CSS 在最顶部，所以浏览器会从最顶部从新向下渲染</span><br><span class="line">  - 所以这里不推荐使用`@import`，因为使用`@import`时，可能会在页面已经渲染完成 link 标签中 CSS 的情况下，然后加入了`@import`中的样式，这时浏览器又会从头渲染一遍 CSS，导致性能的浪费</span><br><span class="line"></span><br><span class="line">### transition 和 animation 的区别</span><br><span class="line"></span><br><span class="line">- transition 只有两个阶段，一个 from，即开始阶段，也是当前阶段，还有一个是 to，就是结束阶段，那么 transition 就只能从当前样式变成另外一个样式</span><br><span class="line">- animation 是动画的意思，那么就很清楚，动画是不止两个阶段的，可以有很多个阶段，也就是 animation 中的 keyframes，我们可以通过设置 keyframes 来设置动画在每一个阶段的样式</span><br><span class="line"></span><br><span class="line">### box-sizing: border-box 特性</span><br><span class="line"></span><br><span class="line">- 设置边框盒子之后，如果设置宽度，再设置内边距 padding 时，不会使盒子变大</span><br><span class="line">- 特例的，如果当盒子宽度没有 padding 宽时，盒子将直接被撑开到 padding 的宽度，例如左右 padding 分别为 50px，但盒子宽度只有 50px，那么盒子将直接被撑开到 100px，也就是 padding 的和</span><br><span class="line"></span><br><span class="line">### item 中的 flex 属性详解</span><br><span class="line"></span><br><span class="line">- flex-grow</span><br><span class="line">  - 用于设置元素分配父容器主轴上剩余空间的比例</span><br><span class="line">  - 假设此时有一个父容器，宽度为 500px 并且设置了 dispaly:flex，然后有两个 item，宽度分别为 200px 和 100px，如果为这两个 item 设置上 flex-grow: 1，意为让他们两个平均分配主轴上的剩余空间，此时剩余空间为 500-200-100=200px，那么每个 item 将会分得 100px，那么第一个盒子就会变成 300px，第二个盒子变为 200px</span><br><span class="line">  - 注意，这时是分配主轴上的剩余空间，所以当 flex-direction 为 row 或 row-reverse 时，分配的便是剩余的宽度，而当 flex-direction 为 column 或 column-reverse 时，分配的便是高度</span><br><span class="line">- flex-shrink</span><br><span class="line">  - 用于设置上主轴上元素超出父容器大小时，缩放的系数</span><br><span class="line">  - 那么什么是缩放系数呢，缩放系数并不像 flex-grow 一样，是对超出空间进行比例分配，这个系数跟 item 实际的宽度或高度也是有关的（如果主轴是横着的就是宽度，主轴是竖着的就是高度，也可以称为在主轴上的长度），那么缩放系数怎么计算呢？应该用**缩放系数\*元素实际在主轴上的长度**，这个得到的值才是真正的缩放比例</span><br><span class="line">  - 加入一个 item 为 300px，一个 item 为 400px，它们的 flex-shrink 分别为 2 和 1，父元素宽度为 400px，如果错误的向 flex-grow 一样计算，那么超出的宽度是 300+400-400=300px，根据它们 flex-shrink，分别需要减去 300\*2/3 和 300\*1/3，当然这样计算是错误的</span><br><span class="line">  - 真正的缩小比例是上面说的缩放系数\*元素在主轴上的长度，那么它们的缩放比例分别就是 2\*300 和 1\*400，所以分别减去的应该是 300\*600/1000 和 300\*400/1000，这才是正确的计算</span><br><span class="line">  - 很重要的一点，计算缩放比例时取的**元素在主轴上的实际宽度**其实是盒子的 content-width，而不是我们实际看到的盒子的宽度，所在当 box-sizing 为 border-box 和 content-box 时，其实计算出来的缩小后的宽度是不一样的</span><br><span class="line">- flex-basis</span><br><span class="line">  - 用于定义元素在主轴上的长度</span><br><span class="line">  - 如果 flex-direction 为 row 或 row-reverse，其实设置的就是宽度，如果 flex-direction 为 column 或 column-reverse，那么设置的就是高度</span><br><span class="line">  - 这个属性的优先级会比 width 或 height 优先级高，就是当 flex-basis 设置了固定值时，flex-basis 会被优先使用</span><br><span class="line">- 参考文章：</span><br><span class="line">  - [深入理解 flex 属性](https://www.cnblogs.com/ghfjj/p/6529733.html)</span><br><span class="line">  - [你不知道的 flex-shrink 计算规则](https://www.cnblogs.com/liyan-web/p/11217330.html)</span><br><span class="line"></span><br><span class="line">### 如何设置多行省略号</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  -webkit-line-clamp: 2; /* 代表几行后为省略号 */</span><br><span class="line">  overflow: hidden;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="为什么-img-是-inline，却可以设置宽高呢"><a href="#为什么-img-是-inline，却可以设置宽高呢" class="headerlink" title="为什么 img 是 inline，却可以设置宽高呢"></a>为什么 img 是 inline，却可以设置宽高呢</h3><ul><li>因为 img 是一个<strong>可替换元素</strong>（replaced element）</li><li>什么是可替换元素呢？这些元素一般是一个外部的对象，它们外观的渲染，是独立于 CSS 的。</li><li>其实就是那种从外部引入的具有内容的东西，但是这些内容又不是 CSS 渲染的，比如说 img，video，embed，iframe，这些都是有一个引入资源的属性，这种元素就叫做可替换元素，像这种元素 CSS 对它们的内容其实是不可操作的，只能操作它们的位置</li><li>参考文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">可替换元素 MDN</a></li></ul><h3 id="border-0-和-border-none-的区别"><a href="#border-0-和-border-none-的区别" class="headerlink" title="border: 0 和 border: none 的区别"></a>border: 0 和 border: none 的区别</h3><ul><li>虽然宽度设置为 border: 0，但是浏览器渲染时仍然会认为 border 存在，随意还会对 border-width 和 border-color 也进行渲染，导致了不必要的消耗</li><li>而 border: none 设置的是边框不存在，随意浏览器将会忽略边框的渲染</li></ul><h3 id="CSS-可视化格式模型（visual-formatting-model）"><a href="#CSS-可视化格式模型（visual-formatting-model）" class="headerlink" title="CSS 可视化格式模型（visual formatting model）"></a>CSS 可视化格式模型（visual formatting model）</h3><ul><li><p>CSS 的可视化格式模型，就是规定 CSS 中的每个盒子（就是由 html 元素生成的盒子）在页面中如何摆放</p></li><li><p>包含块（containing block）</p><ul><li><p>包含块就是一个框，这个框，决定了它的子孙元素如何摆放，一个元素的包含块，指的就是这个元素定位和基准的那个框（基准有定位基准和尺寸基准，如 top：0，width：100%等）</p></li><li><p>那么每个元素的包含块是如何确定的呢？</p><ul><li><p>第一种是根元素，根元素就是文档最顶层的元素，这个元素也有包含块，这个包含块叫做初始化包含块，也就是最顶层的一个包含块</p></li><li><p>第二种是 position 为 static 和 relative 的元素，这些元素的包含块就是 display 为块、单元格和行内块的最近的祖先级元素的内容区，也就是最近的显示类型为块的祖先元素的内容区（内容区就是盒子模型中的 content）</p></li><li><p>第三种是 position 为 fixed，这种元素的包含块，就是浏览器的可视窗口</p></li><li><p>第四种，也是最复杂的，就是 position 为 absolute，它的包含块就是离它最近的定位元素，如果没有定位元素，那包含块其实就是初始包含块，分为以下几种情况</p><ul><li><p>最近的定位属性是行内元素</p><ul><li><p>如果最近的定位元素的 direction 属性为 ltr（内容从左往右显示），那么包含块的范围就是这个行内元素顶左的 padding 的外边界（border 的内边界）到底右的 padding 的外边界</p></li><li><p>```javascript<br><p style="border:1px solid red; width:200px; padding:20px;"><br>  T<br>  <span style="background-color:#C0C0C0; position:relative;"></p><pre><code>这段文字从左向右排列，红 XX 和 蓝 XX 和黄 XX 都是绝对定位元素，它的包含块是相对定位的SPAN。 可以通过它们绝对定位的位置来判断它们包含块的边缘。&lt;em style=&quot;position:absolute; color:red; top:0; left:0;&quot;&gt;XX&lt;/em&gt;&lt;em style=&quot;position:absolute; color:yellow; top:20px; left:0;&quot;&gt;XX&lt;/em&gt;&lt;em style=&quot;position:absolute; color:blue; bottom:0; right:0;&quot;&gt;XX&lt;/em&gt;</code></pre><p>  &lt;/span&gt;<br>&lt;/p&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过上面代码就可以看出</span><br><span class="line"></span><br><span class="line">- 如果最近的定位元素的 direction 属性是 rtl，那么包含块的范围就是这个行内元素的顶右的 padding 外边界到底左的 padding 外边界</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  &lt;p style=&quot;border:1px solid red; width:200px; padding:20px; direction:rtl;&quot;&gt;</span><br><span class="line">    T</span><br><span class="line">    &lt;span style=&quot;background-color:#C0C0C0; position:relative;&quot;&gt;</span><br><span class="line">      这段文字从右向左排列，红 XX 和 蓝 XX 和黄 XX 都是绝对定位元素，它的包含块是相对定位的SPAN。 可以通过它们绝对定位的位置来判断它们……</span><br><span class="line">      &lt;em style=&quot;position:absolute; color:red; top:0; left:0;&quot;&gt;XX&lt;/em&gt;</span><br><span class="line">      &lt;em style=&quot;position:absolute; color:yellow; top:20px; left:0;&quot;&gt;XX&lt;/em&gt;</span><br><span class="line">      &lt;em style=&quot;position:absolute; color:blue; bottom:0; right:0;&quot;&gt;XX&lt;/em&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>其实还有一种奇怪一点的情况，当 direction 为 ltr 时，会不会顶左在底右的右边，那么这个包含块不就是个负的范围了吗</p></li><li><p>```javascript<br><p style="border:1px solid red; width:200px; padding:20px;"><br>  TEXT TEXT TEXT<br>  <span style="background-color:#C0C0C0; position:relative;"></p><pre><code>这段文字从左向右排列，红 XX 和 蓝 XX 和黄 XX 都是绝对定位元素，它的包含块是相对定位的SPAN。 可以通过它们绝对定位的位置来判断它们包含块的边缘。&lt;em style=&quot;position:absolute; color:red; top:0; left:0;&quot;&gt;XX&lt;/em&gt;&lt;em style=&quot;position:absolute; color:yellow; top:20px; left:0;&quot;&gt;XX&lt;/em&gt;&lt;em style=&quot;position:absolute; color:blue; bottom:0; right:0;&quot;&gt;XX&lt;/em&gt;</code></pre><p>  &lt;/span&gt;<br>&lt;/p&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 这时 top：0，left：0 还是在顶左开始摆放的，但是 bottom：0，right：0，并没有在预期的底右开始摆放，而是在底左开始摆放的</span><br><span class="line"></span><br><span class="line">- 最近的定位属性不是行内元素（也就是正常的块级元素）</span><br><span class="line"></span><br><span class="line">  - 当这个最近的定位元素不是行内元素时，就很简单了，那么包含块范围就是这个定位元素的 padding 的外边界</span><br><span class="line"></span><br><span class="line">  - ```javascript</span><br><span class="line">    &lt;div id=”container” style=&quot;padding:50px; background-color:#c0c0c0; position:relative; width:200px; height:200px;&quot;&gt;</span><br><span class="line">        &lt;div id=”div1” style=&quot;width:100%;height:100%;border:2px solid blue;&quot;&gt;</span><br><span class="line">                   &lt;div id=”content” style=&quot;border:1px solid red; position:absolute; left:0; top:0;&quot;&gt;absolute element&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="grid-布局理解"><a href="#grid-布局理解" class="headerlink" title="grid 布局理解"></a>grid 布局理解</h3><ul><li><p>grid 布局跟 flex 布局相似，也是以容器（container）和项目（item）来规定布局，但是相比 flex，grid 的有更强大的能力来控制 item 的位置以及大小</p></li><li><p>开启 grid 布局</p><ul><li>在父元素设置 display: grid;属性，就为盒子开启了 grid 布局，此时设置 display 属性的盒子就是 container</li></ul></li><li><p>容器属性</p><ul><li><p>grid-template-columns 和 grid-template-rows</p><ul><li><p>两个属性用来定义每一列和每一行的宽度和高度的</p></li><li><p>```css<br>.container {<br>  display: grid;<br>  grid-template-columns: 100px 100px 100px;<br>  grid-template-rows: 100px 100px 100px;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上面的代码就表示，盒子内部将会有三行三列的排列，并且宽度和高度都是 100px</span><br><span class="line"></span><br><span class="line">- 除了填写值，还可以使用其他的一些参数</span><br><span class="line"></span><br><span class="line">- repeat()可以指定重复的次数和值，如 repeat(3, 100px)，就可以简写上面的三次 100px，如果是 repeat(3, 10px 20px)，代表重复 10px 和 20px 两次</span><br><span class="line"></span><br><span class="line">- auto-fill 关键字，用在 repeat 的第一个属性，代表长度不固定，直到把行和列填满为止才换行，如 grid-template-columns: repeat(auto-fill, 100px)代表列数不确定，每列宽度为 100px，直到把容器填满为止，才换行</span><br><span class="line"></span><br><span class="line">- fr 关键字，用于表达每列或每行的相对宽度比例</span><br><span class="line"></span><br><span class="line">- minmax()，用于表示在一个范围内取值，如 minmax(100px, 200px)，表示在 100px 和 200px 之间自由调整</span><br><span class="line"></span><br><span class="line">- auto 关键字，自动调整宽度或高度，一般默认会调整到最大值</span><br><span class="line"></span><br><span class="line">- 指定网格线名称，一般在设置这两个属性的时候，还可以指定网格线的名称</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  .container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];</span><br><span class="line">    grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>以上就指定了行上和列上网格线的对应名称，在指定行跨度和列跨度属性的时候可以用到这些网格线的名称</p></li></ul></li><li><p>grid-row-gap、grid-column-gap 和 grid-gap</p><ul><li>代表行之间和列之间的间距</li><li>grid-gap 即前面两个属性的缩写，第一个属性是 row-gap，第二个是 column-gap</li><li>最新的标准中删除了这三个属性的前缀<strong>grid-</strong></li></ul></li><li><p>grid-template-areas</p><ul><li><p>用于指定布局时网格的名称</p></li><li><p>```css<br>.container {<br>  display: grid;<br>  grid-template-columns: 100px 100px 100px;<br>  grid-template-rows: 100px 100px 100px;<br>  grid-template-areas:</p><pre><code>&#39;a b c&#39;&#39;d e f&#39;&#39;g h i&#39;;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 此时就为布局的 9 个网格指定了 a-i 的名称，后续对 item 的定位属性也会使用到这些网格的命名</span><br><span class="line"></span><br><span class="line">    - 这些命名也会影响到网格线的命名，如区域的起始网格线就会命名为**区域名-start**，如 a 区域的起始网格线名称为 a-start</span><br><span class="line"></span><br><span class="line">  - grid-auto-flow</span><br><span class="line"></span><br><span class="line">    - 用于指定 item 的优先排列方向</span><br><span class="line">    - 默认为 row，即优先在行上排列</span><br><span class="line">    - 设置为 column 即优先在列上排列</span><br><span class="line">    - 在 row 或 column 后面还可以加上 dense，代表稠密布局，有时在设置了单元格跨度后，会留下一些空白，默认可能不会填充这些空白，如果使用了 dense 属性后，浏览器就会尽可能的紧密布局</span><br><span class="line"></span><br><span class="line">  - justify-items、align-items 和 place-items</span><br><span class="line"></span><br><span class="line">    - 用于设置单元格内的布局方向</span><br><span class="line">    - 可选属性有 start、end、center、stretch，默认为 stretch</span><br><span class="line">    - place-items 是前两个属性的缩写，第一个代表 align-items</span><br><span class="line"></span><br><span class="line">  - justify-content、align-content 和 place-content</span><br><span class="line"></span><br><span class="line">    - 用于设置单元格在容器内的布局方向，和 flex 相似</span><br><span class="line">    - 属性有 start、end、center、stretch、space-around、space-between、space-evenly</span><br><span class="line">    - 同样 place-content 也是两个属性的简写</span><br><span class="line"></span><br><span class="line">  - grid-auto-columns 和 grid-auto-rows</span><br><span class="line"></span><br><span class="line">    - 有时单元格会超出预先设置的单元格行数和列数，这时单元格的高度和宽度可能会不确定，此时就可以通过这两个属性来指定超出的单元格的高度和宽度</span><br><span class="line"></span><br><span class="line">  - grid-template 和 grid 属性</span><br><span class="line"></span><br><span class="line">    - grid-template 是 grid-template-rows、grid-template-columns 和 grid-template-areas 属性的缩写</span><br><span class="line">    - grid 则是 grid-template-rows、grid-template-columns、grid-template-areas、grid-auto-rows、grid-auto-columns 和 grid-auto-flow 这 6 个属性的缩写</span><br><span class="line"></span><br><span class="line">- 项目（item）属性</span><br><span class="line"></span><br><span class="line">  - grid-column-start、grid-column-end、grid-row-start 和 grid-row-end</span><br><span class="line"></span><br><span class="line">    - 指定属性的 4 个边框，分别定位到哪一根网格线</span><br><span class="line"></span><br><span class="line">    - ```</span><br><span class="line">      grid-column-start属性：左边框所在的垂直网格线</span><br><span class="line">      grid-column-end属性：右边框所在的垂直网格线</span><br><span class="line">      grid-row-start属性：上边框所在的水平网格线</span><br><span class="line">      grid-row-end属性：下边框所在的水平网格线</span><br></pre></td></tr></table></figure></li><li><p>```<br>.item-1 {<br>  grid-column-start: 1;<br>  grid-column-end: 3;<br>  grid-row-start: 1;<br>  grid-row-end: 3;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 以上代码表示，代码占据了起始一个 2x2 的区域</span><br><span class="line"></span><br><span class="line">  - 处理可以使用数值代表网格线之外，还可以使用 areas 中指定的单元格名称对应的网格线名称</span><br><span class="line"></span><br><span class="line">  - 还可以使用 span 数值，来表示单元格个跨度，如 grid-column-start: span 2，表示单元格占据 2 列，在 grid-column-start 和 grid-column-end 中使用 span 的效果是一样的</span><br><span class="line"></span><br><span class="line">- grid-column 和 grid-row</span><br><span class="line"></span><br><span class="line">  - 分别是 grid-column-start、grid-column-end 和 grid-row-start、grid-row-end 属性的缩写</span><br><span class="line"></span><br><span class="line">  - ```css</span><br><span class="line">    .item &#123;</span><br><span class="line">      grid-column: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">      grid-row: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    .item-1 &#123;</span><br><span class="line">      grid-column: 1 / 3;</span><br><span class="line">      grid-row: 1 / 2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>以上是缩写的格式，需要用/隔开每个属性</p></li></ul></li><li><p>grid-area</p><ul><li><p>可以用于指定单元格位于哪一个命名区域</p></li><li><p>```css<br>.item-1 {<br>  grid-area: e;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 以上代码就指定了单元格存在于之前命名为 e 的区域</span><br><span class="line"></span><br><span class="line">- 如果不指定命名区域，还可作为之前的 start 和 end 使用</span><br><span class="line"></span><br><span class="line">- ```css</span><br><span class="line">  .item &#123;</span><br><span class="line">    grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  .item-1 &#123;</span><br><span class="line">    grid-area: 1 / 1 / 3 / 3;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>以上代码就分别指定了 row-start、column-start、row-end、column-end 属性，并且属性之间用/分隔</p></li></ul></li><li><p>justify-self、align-self 和 place-self</p><ul><li>用于指定当前单元格内部的布局方向，和 justify-items 的属性一样，但是只会作用于当前的单元格</li><li>同样 place-self 是前两个属性的简写</li></ul></li></ul></li></ul><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><ul><li>层叠上下文就像是一个外壳，它代表着一个层叠的区域，层叠上下文元素默认就比普通的元素要高一级</li><li>在页面布局时，元素难免会出现层叠的问题，但是出现层叠后，如何来确定谁在上面谁在下面呢</li><li>这时就有重要的两个名词，层叠等级和层叠顺序</li><li>层叠等级顾名思义，描述的就是元素在 z 轴上的上下关系，但是不能把所有元素都归为一类，因为只有当元素在同一个层叠上下文时，它们的比较才是有意义的，所以比较层叠等级只会在同一个层叠上下文中去比较，而对于普通元素来说，我们应该比较它们所处在的层叠上下文的等级</li><li>层叠顺序则指的是比较层叠等级的一种规则，这个规则就规定了当元素发生层叠时，谁应该在上面，谁应该在下面，在不考虑 CSS3 的情况向下，规则如下图所示<ul><li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODcyMDM1OC0xMjlhMmMzMWIyN2Y3YzU1LnBuZw" alt=""></li><li>其中层叠上下文 background/border 指的是对于一个元素来讲，它所处的层叠上下文的 background/border 是层叠等级最低的，所以就是为什么默认情况下看到的嵌套内的元素会覆盖嵌套外的元素</li><li>而对于 inline/inline-block 的等级为什么这么高，因为这种元素本身用于包含文本，而文本是网页的主要内容，所以应该居于上方</li></ul></li><li>层叠上下文的产生<ul><li>默认情况下，根元素会创建默认的根层叠上下文，也就是我们的 html 元素就是根层叠上下文</li><li>普通的元素在设置定位属性之后（不为 static），并且设置 z-index 属性（不为 auto），这时就会为这个元素创建层叠上下文，并且这个元素会变成层叠上下文元素，意思就是它会比普通的元素高出一个等级</li><li>在 CSS3 中使用一些属性也会产生层叠上下文<ul><li>使用<code>display: flex</code>，并且其子元素设置了<code>z-index</code>，此时子元素就会创建层叠上下文</li><li>当<code>opacity</code>不为<code>1</code>时</li><li>当<code>transform</code>不为<code>none</code>时</li><li>当<code>mix-blend-mode</code>不为<code>normal</code>时</li><li>当<code>filter</code>不为<code>none</code>时</li><li>当<code>isolation</code>的值不是<code>isolate</code>时</li><li>当<code>will-change</code>属性是以上几个属性时</li><li>当<code>-webkit-overflow-scrolling</code>属性值设置为<code>touch</code></li></ul></li></ul></li><li>比较层叠关系的方法<ul><li>如果两个元素处于同一个层叠上下文中，那么就比较它们的层叠等级，可以根据层叠顺序图来进行比较</li><li>如果两个元素不处在同一个层叠上下文中，那么需要比较它们所处的层叠上下文，如果层叠等级相同，那么就比较它们在 DOM 中出现的顺序，谁后出现谁就在上面</li></ul></li></ul><h2 id="5-Vue-js-基础"><a href="#5-Vue-js-基础" class="headerlink" title="5.Vue.js 基础"></a>5.Vue.js 基础</h2><h3 id="Vue-有哪些生命周期"><a href="#Vue-有哪些生命周期" class="headerlink" title="Vue 有哪些生命周期"></a>Vue 有哪些生命周期</h3><ul><li><code>beforeCreate()</code> 在实例创建之间执行，数据未加载状态</li><li><p><code>created()</code> 在实例创建、数据加载后，能初始化数据，<code>dom</code>渲染之前执行</p></li><li><p><code>beforeMount()</code> 虚拟<code>dom</code>已创建完成，在数据渲染前最后一次更改数据</p></li><li><p><code>mounted()</code> 页面、数据渲染完成，真实<code>dom</code>挂载完成</p></li><li><p><code>beforeUpadate()</code> 重新渲染之前触发</p></li><li><p><code>updated()</code> 数据已经更改完成，<code>dom</code> 也重新 <code>render</code> 完成,更改数据会陷入死循环</p></li><li><p><code>beforeDestory()</code> 和 <code>destoryed()</code> 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行</p></li></ul><h3 id="一般在哪个生命周期请求异步数据"><a href="#一般在哪个生命周期请求异步数据" class="headerlink" title="一般在哪个生命周期请求异步数据"></a>一般在哪个生命周期请求异步数据</h3><ul><li>异步请求在哪个阶段都可以调用，因为会先执行完生命周期的钩子函数之后，才会执行异步函数，但如果考虑用户体验方面的话，在 created 中调用异步请求最佳，用户就越早感知页面的已加载，毕竟越早获取数据，在 mounted 实例挂载的时候就越及时。</li></ul><h3 id="v-if-和-v-show-的差别"><a href="#v-if-和-v-show-的差别" class="headerlink" title="v-if 和 v-show 的差别"></a>v-if 和 v-show 的差别</h3><ul><li><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。当 v-show 赋值为 false 时，元素被隐藏，此时查看代码时，该元素上会多一个内联样式 style=“display:none”</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p></li></ul><h3 id="vue-的-nextTick-有什么用？"><a href="#vue-的-nextTick-有什么用？" class="headerlink" title="vue 的 nextTick 有什么用？"></a>vue 的 nextTick 有什么用？</h3><ul><li>作用是在下一次 DOM 更新循环结束后调用指定的回调函数。</li><li>因为 Vue 中更改数据后，对应的 DOM 并不是同步更新的，而是放在了 DOM 更新队列中进行异步更新，所以在修改完数据之后，DOM 其实还没有改变，如果这时我们想要获取 DOM 的话，是无法获取的，所有只有使用 nextTick 提供的回调函数对改变后的 DOM 进行获取。</li><li>实现原理<ul><li>因为 vue 对 dom 更新进行异步管理，会将这一轮的 dom 更新任务添加到本轮事件循环的微任务中，然后 nextTick 就会将回调函数以微任务的形式添加到微任务的尾部，因为 ui 渲染会在本轮所有微任务执行完之后才进行，所以 nextTick 函数能以最快的速度获得到更新后的 dom（因为 dom 更新对于浏览器来说其实是同步的，而 ui 渲染会等待，而不是立即渲染）</li></ul></li></ul><h3 id="v-for-中-key-的作用"><a href="#v-for-中-key-的作用" class="headerlink" title="v-for 中 key 的作用"></a>v-for 中 key 的作用</h3><ul><li>key 用来唯一标识一个元素</li><li>因为 v-for 根据数据进行渲染，如果数据改变，那么就会导致虚拟 dom 重新构建，然后经过 diff 算法后渲染改变的视图，如果没有 key 属性，如果在一组数据中间插入了一个新数据，那么就会导致从这个新数据开始，全部的元素都会被替换，因为虚拟 dom 没有途径来判断剩下的元素是否改变，所以就只能替换</li><li>但是如果有 key 的标识，那么虚拟 dom 在判断时，只用判断 key，就能很轻松的判断出这组数据中改变了哪个位置，然后找到对应的位置，对真实 dom 进行重新渲染</li></ul><h3 id="vue-事件监听的修饰符"><a href="#vue-事件监听的修饰符" class="headerlink" title="vue 事件监听的修饰符"></a>vue 事件监听的修饰符</h3><ul><li>stop：阻止事件的冒泡行为</li><li>prevent：阻止事件对于浏览器的默认行为</li><li>once：让事件只会触发一次</li><li>self：只有自身能触发事件，通过捕获或者冒泡都不会触发</li></ul><h3 id="proxy-和-Object-defineProperty-的区别"><a href="#proxy-和-Object-defineProperty-的区别" class="headerlink" title="proxy 和 Object.defineProperty 的区别"></a>proxy 和 Object.defineProperty 的区别</h3><ul><li>proxy 是对于对象进行拦截，而 defineProperty 是对对象的属性进行拦截</li><li>proxy 可以监听到对象的增加，还可以监听到对象的删除</li><li>proxy 可以监听对数组的操作，但 defineProperty 不行</li><li>proxy 是 es6 的语法，defineProperty 是 IE8+支持的</li></ul><h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h3><ul><li>computed 计算属性，用于添加一个属性，依赖于其他属性，当依赖属性改变时，计算属性也会随之改变，并且同时更新视图<ul><li>支持缓存，只有依赖值改变时才会改变（意思是不会重复计算）</li><li>不支持异步操作，因为计算属性会直接同步返回对应的计算出来的值</li><li>如果为 computed 设置一个函数，则函数作为取值函数 get，如果设置一个对象，则可以在对象中设置两个属性，一个取值函数 get，一个赋值函数 set</li></ul></li><li>watch 用于监听某个属性的改变，执行相应的操作<ul><li>不支持缓存，当监听的数据改变时，直接触发相应的操作</li><li>支持异步操作，当监听的属性改变时，可以进行想要的操作，如异步更改数据等等</li><li>为 watch 设置一个函数时，则属性改变时直接触发该函数，为 watch 设置一个对象时，可以设置 deep 属性，用于深度监听（当监听的属性是一个对象时，可以监听对象内部的改变，但是不能监听数组内部的改变），还有一个属性 handler 就是处理函数</li></ul></li></ul><h2 id="6-Vue-js-原理性问题"><a href="#6-Vue-js-原理性问题" class="headerlink" title="6.Vue.js 原理性问题"></a>6.Vue.js 原理性问题</h2><h2 id="7-计算机网络"><a href="#7-计算机网络" class="headerlink" title="7.计算机网络"></a>7.计算机网络</h2><h3 id="HTTP-常见状态码"><a href="#HTTP-常见状态码" class="headerlink" title="HTTP 常见状态码"></a>HTTP 常见状态码</h3><ul><li><p>|     | 类别                             | 原因短语                   |<br>| —- | ———————————————— | ————————————— |<br>| 1xx | Information（信息状态码）        | 接受的请求正在处理         |<br>| 2xx | Success（成功状态码）            | 请求正常处理完毕           |<br>| 3xx | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |<br>| 4xx | Client Error（客户端错误状态码） | 服务器无法处理请求         |<br>| 5xx | Server Error（服务端错误状态码） | 服务器处理请求出错         |</p></li><li><p>200 OK</p><ul><li>200 表示请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。</li></ul></li><li><p>204 No Content</p><ul><li><p>204 表示服务器接收的请求已经成功处理，但是在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。当浏览器在发送请求后接收到 204 响应，它的显示页面不会发生更新。</p></li><li><p>通常应用在只需要客户端往服务端发送信息，而服务端不需要发送新信息的情况下使用。</p></li></ul></li><li><p>206 Partial Content</p><ul><li>206 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文内包含由 Content-Range 指定范围的实体内容。</li></ul></li><li><p>301 Moved Permanently</p><ul><li>永久重定向，301 状态码表示请求的资源已经分配了新的 URI，以后请求该资源应该访问新的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</li></ul></li><li><p>302 Found</p><ul><li>临时重定向，302 表示请求的资源已经被分配了新的 URI，希望客户端本次能使用新的 URI 访问。和 301 不同的是，这种资源的 URI 变更是临时的额，而不是永久的，因此不用去更新书签。</li></ul></li><li><p>303 See Other</p><ul><li><p>该状态码和 302 有着异曲同工之妙，表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p></li><li><p>如果浏览器原本是用 POST 方法去请求服务器，收到 303 状态码之后，会改用 GET 并访问资源新的 URI。</p></li></ul></li><li><p>304 Not Modified</p><ul><li><p>304 状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。例如，客户端请求的资源在客户端本地已有缓存，会在请求头部中加入“If-Modified-Since”, “If-None-Match”等字段，服务端根据这些字段信息判断这些资源信息是否经过修改，如果没有则返回 304 状态码，客户端可以直接使用缓存中的资源。</p></li><li><p>304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p></li><li><p>PS：附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。</p></li></ul></li><li><p>307 Temporary Redirect</p><ul><li>临时重定向，和 302 Found 状态码有相同的含义。区别在于 307 不会强制浏览器将 POST 方法改为 GET 方法，而是遵循浏览器自身的标准。</li></ul></li><li><p>400 Bad Request</p><ul><li>400 状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</li><li>表示客户端发送的数据格式与服务器期望的数据格式不匹配</li></ul></li><li><p>401 Unauthorized</p><ul><li>401 状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。第一次收到 401 状态码表示需要进行用户认证，第二次再收到 401 状态码说明用户认证失败。</li></ul></li><li><p>403 Forbidden</p><ul><li>403 状态码表明对请求资源的访问被服务器拒绝了，当未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能发生 403 。</li></ul></li><li><p>404 Not Found</p><ul><li>404 是我们最常见的状态码之一，它表示服务器上无法找到请求资源。此外，也可能是服务器端在拒绝请求且不想说明原因的时候使用。</li></ul></li><li><p>500 Internal Server Error</p><ul><li>500 状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</li></ul></li><li><p>503 Service Unavailable</p><ul><li>503 状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul></li></ul><h3 id="TCP-建立连接三次握手，为什么？"><a href="#TCP-建立连接三次握手，为什么？" class="headerlink" title="TCP 建立连接三次握手，为什么？"></a>TCP 建立连接三次握手，为什么？</h3><ul><li>第一次客户端向服务器发起请求，此时双方都还不能确定是否对方已收到自己的消息</li><li>第二次服务器回复客户端第一次发起的请求，此时客户端可以确定服务器已经收到了自己的消息，但服务器还不能确定客户端已经收到了消息。</li><li>第三次客户端再回复一次服务器的请求，此时客户端和服务器都得到了一次确定，因此可以建立连接，进行数据的传输。</li><li>为什么要三次，如果是两次会发生什么？<ul><li>如果是两次，可能出现这种情况。客户端向服务器发起了连接请求，但是这个连接请求在网络中延迟了，因此客户端在等待一段时间后，发现服务器没有对它进行响应，因此就放弃了本次连接。</li><li>但在网络延迟后，数据到达了服务器，服务器以为是客户端向他请求的一个有效连接，如果是两次握手，那么此时服务器就会与客户端建立起连接，但这个连接其实是无效的，因为客户端其实已经放弃了本次连接，所以会导致服务器等待客户端发送消息，因此就在服务器中占用了不必要的资源。</li></ul></li></ul><h3 id="TCP-断开连接的四次挥手，为什么？"><a href="#TCP-断开连接的四次挥手，为什么？" class="headerlink" title="TCP 断开连接的四次挥手，为什么？"></a>TCP 断开连接的四次挥手，为什么？</h3><ul><li>第一次是客户端向服务端发起关闭的请求，这代表客户端已经没有数据要发送了，但是此时其实客户端还可以接收数据</li><li>第二次是服务器收到消息后，得知了客户端不发送消息了，因为就回复客户端，已经收到关闭请求，此时服务器端就会关闭自己的接收通道，客户端收到消息后也会关闭它的发送通道，但是此时服务器可能还有消息在发，所以并没关闭自己的发送通道，客户端也没有关闭接收通道</li><li>第三次，当服务端的消息发送完毕后，就会再次通知客户端，消息已经发送完毕了，可以关闭你的接收通道了</li><li>第四次是客户端接收到服务器的关闭请求后，然后告知服务端已经收到了关闭的请求，这时客户端就可以关闭消息接收通道，服务端收到消息后也会对应的关闭最后的消息发送通道</li></ul><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul><li>TCP 是面向连接的，提供有序、无差错、不重复、数据重传、拥塞控制等机制</li><li>UDP 是无连接传输，所以 UDP 只能尽最大努力交付</li><li>因此 TCP 是可靠的传输协议，UDP 是不可靠的</li></ul><h3 id="TCP-是如何保证可靠传输的"><a href="#TCP-是如何保证可靠传输的" class="headerlink" title="TCP 是如何保证可靠传输的"></a>TCP 是如何保证可靠传输的</h3><ul><li>TCP 通过确认和重传、流量控制、拥塞控制保证传输的可靠性</li><li>滑动窗口原理（用于流量控制）<ul><li>首先为发送方和接收方分别创建发送窗口和接收窗口</li><li>发送方最先会向接收方请求发送数据，接收方便会返回一个带有<strong>确认号</strong>和<strong>窗口值</strong>的报文段给发送方，<strong>确认号</strong>表示发送方可以发送起始数据编号和接收方期望收到数据的数据编号，<strong>窗口值</strong>表示当前可发送和可接收编号的长度</li><li>此时发送方就可发送窗口内的所有数据给接收方，接收方收到数据后，会将收到的数据放在窗口缓存中（当然这些数据是允许接收的，也就是接收窗口内允许的数据），当收到的数据形成了从窗口尾部开始的连续数据，就会将本段连续数据的<strong>最大编号+1</strong>作为确认号，作为确认回复给发送方，此时发送方就是按照确认号和窗口值，对发送窗口进行调整，同样接收方也会对接收窗口进行调整</li><li>如果发送的数据在指定的时间内没有得到确认，那么将会对数据进行重传，以保证传输的可靠性</li></ul></li><li>拥塞控制算法<ul><li>四种情况：慢开始、拥塞避免、快重传、快恢复</li><li>ssthresh 为门限值，cwnd 为当前窗口大小</li><li>最初 cwnd 窗口大小为 1，当窗口大小未达到门限值的时候，采用慢开始算法，即进行指数增长</li><li>当窗口值到达门限值后，开始采用拥塞避免算法，即线性增长，每次+1</li><li>如果在增加窗口大小的过程中，出现了网络拥塞，则会将 cwnd 重新设置为 1，并且将门限值修改为当前出现拥塞的 cwnd 的一半，之后继续按照规则进行</li><li>在发送的过程中，可能会收到 3 个重复的确认，称为 3ack，这是便执行快重传算法，即将 cwnd 的值设置为当前 cwnd 的一半，把门限值 ssthresh 也设置为当前 cwnd 的一半，然后就开始快恢复算法，其实快恢复算法就跟拥塞避免一样，让 cwnd 进行线性增长，即每次+1</li></ul></li></ul><h2 id="8-计算机操作系统"><a href="#8-计算机操作系统" class="headerlink" title="8.计算机操作系统"></a>8.计算机操作系统</h2><h2 id="9-浏览器安全"><a href="#9-浏览器安全" class="headerlink" title="9. 浏览器安全"></a>9. 浏览器安全</h2><h4 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h4><p>xss 攻击就是在用户网页中插入恶意的代码，使得恶意代码被执行，从而对用户的网站造成攻击</p><p>xss 攻击的两种类型：#</p><p>反射型：</p><p>指非持久性的 xss 攻击，比如用户的页面要显示一个信息，但是这个信息的内容可以通过浏览器的 url 传递过来，然后直接把传递过来的某个参数直接渲染到页面上，这种情况，如果渲染的内容没有被过滤，直接渲染出 url 中包含的参数，那么攻击者就可以在这个参数中插入一段恶意的代码，使得参数被渲染到页面上时，被执行，从而造成攻击</p><p>存储型：</p><p>指持久性的 xss 攻击，如用户提交的表单内容，如果有一个表单内容被存储到数据库中，并且没有被过滤，在后续的网页中会使用到这个表单内容，并渲染到浏览器页面上，那么就可能存在 xss 攻击，当攻击者提交带有攻击性脚本的表单内容，那么在后续这段内容被渲染出来的时候，就会对网站造成攻击，因为是存储在数据库中的，该攻击可能会被触发无限多次，因此称为存储型 xss 攻击</p><p>xss 的注入点：</p><ol><li>html 的节点内容，即脚本被插入到 html 中</li><li>html 属性，如果图片的 src 属性，比如用户图片是通过拼接的方式形成的，那么就可以在图片链接中，通过截断图片链接的方式，然后在连接后面插入 onerror 回调，从而执行攻击者的代码</li><li>富文本中，富文本本身可以插入任意 html，因此造成攻击的可能会更大，不能简单的通过过滤字符来完成，而应该通过过滤掉潜在的标签和标签属性，来防止 xss 的攻击</li></ol><h4 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h4><p>主要是通过用户在 a 网站登录后，并将授权信息存储在 cookie 中，然后通过诱导用户去访问第三方网站 b，在网站 b 中有一个指向网站 a 的请求，浏览器判断用户是去访问网站 a，浏览器就在这条请求中携带上了网站 a 的 cookie，从而使第三方网站 b 可以利用网站 a 的授权，对网站 a 的用户造成攻击</p><p>防御的方式：</p><ol><li>通过 referer 请求头，判断发起请求的网站是否是自己的网站</li><li>通过 csrf token，可以在用户登录成功后，后端发送一个 csrf token，要求用户在请求中，都在请求头中带上这个 token，后端可以根据这个 token 的正确性，来保证请求是从我们自己的网站发出的</li><li>双 cookie 校验，可以在 http 请求头中加上一个自定义的字段，在字段中加入我们的 cookie，使得请求头中拥有两个 cookie，后端可以通过判断这两个 cookie 是否相等，从而判断请求是否从网站 a 发出</li></ol><h3 id="10-前端性能优化"><a href="#10-前端性能优化" class="headerlink" title="10.前端性能优化"></a>10.前端性能优化</h3><h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><p>使用图片懒加载可以有效防止资源在不必使用时被加载出来，可以有效减少每次的请求次数，从而防止浏览器请求队头阻塞等情况</p><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>可以使用 url-loader 对体积较小的图片进行 base64 编码，从而提高图片的加载速度，从而使得图片能跟 html 文件同时到达</p><p>还可以使用 image-webpack-loader 对图片进行压缩</p><h4 id="CDN-网络优化"><a href="#CDN-网络优化" class="headerlink" title="CDN 网络优化"></a>CDN 网络优化</h4><p>可以通过使用 CDN 资源，来对资源进行有效的缓存，从而加快对于资源的加载速度</p><p>在 index.html 中直接引入资源，如果使用了 webpack，可以配置 externals 选项，放置 cdn 资源被打包进入项目</p><h4 id="请求压缩优化-gzip"><a href="#请求压缩优化-gzip" class="headerlink" title="请求压缩优化 gzip"></a>请求压缩优化 gzip</h4><p>可以在服务端开启对于资源的 gzip 压缩，从而减小文件的体积，提高传输的速度</p><p>在打包项目时还能直接使用 compress-webpack-plugin 对资源进行 gzip 压缩，在服务端时就可以直接通过发送 gzip 文件，而减去压缩资源的时间</p><h4 id="项目字体优化"><a href="#项目字体优化" class="headerlink" title="项目字体优化"></a>项目字体优化</h4><p>可以适当使用工具删除字体中不需要的字体，如项目只有简体中文的文字，那么就可以删除其它没有必要的文字</p><p>如果对于项目中存在静态字体，那么就可以使用 font-spider 对静态字体进行提取，然后生成只包含静态字体的字体文件，从而减少字体文件的大小</p><h4 id="资源预加载与预取"><a href="#资源预加载与预取" class="headerlink" title="资源预加载与预取"></a>资源预加载与预取</h4><p>可以对页面中的核心资源进行 preload 预加载，从而在界面渲染出来的时候就能即使使用到资源</p><p>而对于一些当前不使用，但是即将可能使用的资源，可以使用 preload 预取，在浏览器空闲时就会对资源进行预取，从而在资源真正被使用时可以通过直接从缓存中获取</p><p>在一般项目中可以使用 preload-webpack-plugin 来使用对核心资源的预加载设置，从而在打包时配合 html-webpack-plugin 将资源插入到 html 文件中，还可以设置将指定资源进行 prefetch</p><p>在 vue-cli3 以上的脚手架中，会自动对初次渲染需要的核心内容进行 preload 预加载，对所有使用 import 函数引入的资源，即被 code splitting 的资源进行 prefetch 预取</p><h4 id="tree-shaking-优化"><a href="#tree-shaking-优化" class="headerlink" title="tree shaking 优化"></a>tree shaking 优化</h4><p>使用支持 tree shaking 的包，即使用 esm 规范开发的包文件</p><h4 id="应用预渲染"><a href="#应用预渲染" class="headerlink" title="应用预渲染"></a>应用预渲染</h4><p>可以使用 prerender-spa-plugin 对应用的必要页面进行预渲染，如果该页面中存在过多的静态资源，但是这些资源又是通过 js 渲染出来的，就可以通过预渲染，在编译阶段就将这些内容直接渲染成静态的代码，从而加快内容被渲染出来的速度</p><h4 id="原子化-css"><a href="#原子化-css" class="headerlink" title="原子化 css"></a>原子化 css</h4><p>可以有效防止 css 嵌套层数过多的问题，原子化 css 中定义很多可以被直接使用的类名，因此可以直接使用这些类名来编写 css 的样式，从而就避免了类名嵌套多层的情况出现</p><h4 id="如何衡量前端性能，性能指标"><a href="#如何衡量前端性能，性能指标" class="headerlink" title="如何衡量前端性能，性能指标"></a>如何衡量前端性能，性能指标</h4><p>首屏加载速度，FCP first contentful paint，首屏渲染的时间是第一个衡量前端性能的标准，即用户可以看到我们网页内容的时间，一般可以用通过浏览器的 lighthouse 工具，或者使用 js 的 preformance 来计算出首屏的时间</p><p>第二标准是 LCP，largest contentful paint，即页面中最大内容被绘制出来的时间</p><p>第三个标准 FID，first input delay，即用户第一次与页面交互浏览器响应交互需要的时间，即用户首次交互需要等待的时间，也可以衡量一个应用的性能</p><p>第四个标准 TTI，time to interactive，即页面中所有资源都能够进行响应的时间，即响应用户所有操作的时间点</p><p>—end</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://fanned1.github.io/posts/undefined.html"/>
    <id>https://fanned1.github.io/posts/undefined.html</id>
    <published>2022-11-09T07:03:20.912Z</published>
    <updated>2022-11-09T07:03:20.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
